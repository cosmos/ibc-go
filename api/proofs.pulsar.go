// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package api

import (
	fmt "fmt"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	io "io"
	reflect "reflect"
	sync "sync"
)

var _ protoreflect.List = (*_ExistenceProof_4_list)(nil)

type _ExistenceProof_4_list struct {
	list *[]*InnerOp
}

func (x *_ExistenceProof_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ExistenceProof_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_ExistenceProof_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*InnerOp)
	(*x.list)[i] = concreteValue
}

func (x *_ExistenceProof_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*InnerOp)
	*x.list = append(*x.list, concreteValue)
}

func (x *_ExistenceProof_4_list) AppendMutable() protoreflect.Value {
	v := new(InnerOp)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ExistenceProof_4_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_ExistenceProof_4_list) NewElement() protoreflect.Value {
	v := new(InnerOp)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ExistenceProof_4_list) IsValid() bool {
	return x.list != nil
}

var (
	md_ExistenceProof       protoreflect.MessageDescriptor
	fd_ExistenceProof_key   protoreflect.FieldDescriptor
	fd_ExistenceProof_value protoreflect.FieldDescriptor
	fd_ExistenceProof_leaf  protoreflect.FieldDescriptor
	fd_ExistenceProof_path  protoreflect.FieldDescriptor
)

func init() {
	file_proofs_proto_init()
	md_ExistenceProof = File_proofs_proto.Messages().ByName("ExistenceProof")
	fd_ExistenceProof_key = md_ExistenceProof.Fields().ByName("key")
	fd_ExistenceProof_value = md_ExistenceProof.Fields().ByName("value")
	fd_ExistenceProof_leaf = md_ExistenceProof.Fields().ByName("leaf")
	fd_ExistenceProof_path = md_ExistenceProof.Fields().ByName("path")
}

var _ protoreflect.Message = (*fastReflection_ExistenceProof)(nil)

type fastReflection_ExistenceProof ExistenceProof

func (x *ExistenceProof) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ExistenceProof)(x)
}

func (x *ExistenceProof) slowProtoReflect() protoreflect.Message {
	mi := &file_proofs_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ExistenceProof_messageType fastReflection_ExistenceProof_messageType
var _ protoreflect.MessageType = fastReflection_ExistenceProof_messageType{}

type fastReflection_ExistenceProof_messageType struct{}

func (x fastReflection_ExistenceProof_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ExistenceProof)(nil)
}
func (x fastReflection_ExistenceProof_messageType) New() protoreflect.Message {
	return new(fastReflection_ExistenceProof)
}
func (x fastReflection_ExistenceProof_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ExistenceProof
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ExistenceProof) Descriptor() protoreflect.MessageDescriptor {
	return md_ExistenceProof
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ExistenceProof) Type() protoreflect.MessageType {
	return _fastReflection_ExistenceProof_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ExistenceProof) New() protoreflect.Message {
	return new(fastReflection_ExistenceProof)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ExistenceProof) Interface() protoreflect.ProtoMessage {
	return (*ExistenceProof)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ExistenceProof) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Key) != 0 {
		value := protoreflect.ValueOfBytes(x.Key)
		if !f(fd_ExistenceProof_key, value) {
			return
		}
	}
	if len(x.Value) != 0 {
		value := protoreflect.ValueOfBytes(x.Value)
		if !f(fd_ExistenceProof_value, value) {
			return
		}
	}
	if x.Leaf != nil {
		value := protoreflect.ValueOfMessage(x.Leaf.ProtoReflect())
		if !f(fd_ExistenceProof_leaf, value) {
			return
		}
	}
	if len(x.Path) != 0 {
		value := protoreflect.ValueOfList(&_ExistenceProof_4_list{list: &x.Path})
		if !f(fd_ExistenceProof_path, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ExistenceProof) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ics23.ExistenceProof.key":
		return len(x.Key) != 0
	case "ics23.ExistenceProof.value":
		return len(x.Value) != 0
	case "ics23.ExistenceProof.leaf":
		return x.Leaf != nil
	case "ics23.ExistenceProof.path":
		return len(x.Path) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.ExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.ExistenceProof does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExistenceProof) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ics23.ExistenceProof.key":
		x.Key = nil
	case "ics23.ExistenceProof.value":
		x.Value = nil
	case "ics23.ExistenceProof.leaf":
		x.Leaf = nil
	case "ics23.ExistenceProof.path":
		x.Path = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.ExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.ExistenceProof does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ExistenceProof) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ics23.ExistenceProof.key":
		value := x.Key
		return protoreflect.ValueOfBytes(value)
	case "ics23.ExistenceProof.value":
		value := x.Value
		return protoreflect.ValueOfBytes(value)
	case "ics23.ExistenceProof.leaf":
		value := x.Leaf
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "ics23.ExistenceProof.path":
		if len(x.Path) == 0 {
			return protoreflect.ValueOfList(&_ExistenceProof_4_list{})
		}
		listValue := &_ExistenceProof_4_list{list: &x.Path}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.ExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.ExistenceProof does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExistenceProof) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ics23.ExistenceProof.key":
		x.Key = value.Bytes()
	case "ics23.ExistenceProof.value":
		x.Value = value.Bytes()
	case "ics23.ExistenceProof.leaf":
		x.Leaf = value.Message().Interface().(*LeafOp)
	case "ics23.ExistenceProof.path":
		lv := value.List()
		clv := lv.(*_ExistenceProof_4_list)
		x.Path = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.ExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.ExistenceProof does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExistenceProof) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.ExistenceProof.leaf":
		if x.Leaf == nil {
			x.Leaf = new(LeafOp)
		}
		return protoreflect.ValueOfMessage(x.Leaf.ProtoReflect())
	case "ics23.ExistenceProof.path":
		if x.Path == nil {
			x.Path = []*InnerOp{}
		}
		value := &_ExistenceProof_4_list{list: &x.Path}
		return protoreflect.ValueOfList(value)
	case "ics23.ExistenceProof.key":
		panic(fmt.Errorf("field key of message ics23.ExistenceProof is not mutable"))
	case "ics23.ExistenceProof.value":
		panic(fmt.Errorf("field value of message ics23.ExistenceProof is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.ExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.ExistenceProof does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ExistenceProof) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.ExistenceProof.key":
		return protoreflect.ValueOfBytes(nil)
	case "ics23.ExistenceProof.value":
		return protoreflect.ValueOfBytes(nil)
	case "ics23.ExistenceProof.leaf":
		m := new(LeafOp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "ics23.ExistenceProof.path":
		list := []*InnerOp{}
		return protoreflect.ValueOfList(&_ExistenceProof_4_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.ExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.ExistenceProof does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ExistenceProof) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ics23.ExistenceProof", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ExistenceProof) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExistenceProof) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ExistenceProof) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ExistenceProof) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ExistenceProof)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Key)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Value)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Leaf != nil {
			l = options.Size(x.Leaf)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Path) > 0 {
			for _, e := range x.Path {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ExistenceProof)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Path) > 0 {
			for iNdEx := len(x.Path) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Path[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x22
			}
		}
		if x.Leaf != nil {
			encoded, err := options.Marshal(x.Leaf)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Value) > 0 {
			i -= len(x.Value)
			copy(dAtA[i:], x.Value)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Value)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Key) > 0 {
			i -= len(x.Key)
			copy(dAtA[i:], x.Key)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Key)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ExistenceProof)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExistenceProof: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExistenceProof: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Key = append(x.Key[:0], dAtA[iNdEx:postIndex]...)
				if x.Key == nil {
					x.Key = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Value = append(x.Value[:0], dAtA[iNdEx:postIndex]...)
				if x.Value == nil {
					x.Value = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Leaf", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Leaf == nil {
					x.Leaf = &LeafOp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Leaf); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Path = append(x.Path, &InnerOp{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Path[len(x.Path)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_NonExistenceProof       protoreflect.MessageDescriptor
	fd_NonExistenceProof_key   protoreflect.FieldDescriptor
	fd_NonExistenceProof_left  protoreflect.FieldDescriptor
	fd_NonExistenceProof_right protoreflect.FieldDescriptor
)

func init() {
	file_proofs_proto_init()
	md_NonExistenceProof = File_proofs_proto.Messages().ByName("NonExistenceProof")
	fd_NonExistenceProof_key = md_NonExistenceProof.Fields().ByName("key")
	fd_NonExistenceProof_left = md_NonExistenceProof.Fields().ByName("left")
	fd_NonExistenceProof_right = md_NonExistenceProof.Fields().ByName("right")
}

var _ protoreflect.Message = (*fastReflection_NonExistenceProof)(nil)

type fastReflection_NonExistenceProof NonExistenceProof

func (x *NonExistenceProof) ProtoReflect() protoreflect.Message {
	return (*fastReflection_NonExistenceProof)(x)
}

func (x *NonExistenceProof) slowProtoReflect() protoreflect.Message {
	mi := &file_proofs_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_NonExistenceProof_messageType fastReflection_NonExistenceProof_messageType
var _ protoreflect.MessageType = fastReflection_NonExistenceProof_messageType{}

type fastReflection_NonExistenceProof_messageType struct{}

func (x fastReflection_NonExistenceProof_messageType) Zero() protoreflect.Message {
	return (*fastReflection_NonExistenceProof)(nil)
}
func (x fastReflection_NonExistenceProof_messageType) New() protoreflect.Message {
	return new(fastReflection_NonExistenceProof)
}
func (x fastReflection_NonExistenceProof_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_NonExistenceProof
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_NonExistenceProof) Descriptor() protoreflect.MessageDescriptor {
	return md_NonExistenceProof
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_NonExistenceProof) Type() protoreflect.MessageType {
	return _fastReflection_NonExistenceProof_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_NonExistenceProof) New() protoreflect.Message {
	return new(fastReflection_NonExistenceProof)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_NonExistenceProof) Interface() protoreflect.ProtoMessage {
	return (*NonExistenceProof)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_NonExistenceProof) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Key) != 0 {
		value := protoreflect.ValueOfBytes(x.Key)
		if !f(fd_NonExistenceProof_key, value) {
			return
		}
	}
	if x.Left != nil {
		value := protoreflect.ValueOfMessage(x.Left.ProtoReflect())
		if !f(fd_NonExistenceProof_left, value) {
			return
		}
	}
	if x.Right != nil {
		value := protoreflect.ValueOfMessage(x.Right.ProtoReflect())
		if !f(fd_NonExistenceProof_right, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_NonExistenceProof) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ics23.NonExistenceProof.key":
		return len(x.Key) != 0
	case "ics23.NonExistenceProof.left":
		return x.Left != nil
	case "ics23.NonExistenceProof.right":
		return x.Right != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.NonExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.NonExistenceProof does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NonExistenceProof) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ics23.NonExistenceProof.key":
		x.Key = nil
	case "ics23.NonExistenceProof.left":
		x.Left = nil
	case "ics23.NonExistenceProof.right":
		x.Right = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.NonExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.NonExistenceProof does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_NonExistenceProof) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ics23.NonExistenceProof.key":
		value := x.Key
		return protoreflect.ValueOfBytes(value)
	case "ics23.NonExistenceProof.left":
		value := x.Left
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "ics23.NonExistenceProof.right":
		value := x.Right
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.NonExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.NonExistenceProof does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NonExistenceProof) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ics23.NonExistenceProof.key":
		x.Key = value.Bytes()
	case "ics23.NonExistenceProof.left":
		x.Left = value.Message().Interface().(*ExistenceProof)
	case "ics23.NonExistenceProof.right":
		x.Right = value.Message().Interface().(*ExistenceProof)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.NonExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.NonExistenceProof does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NonExistenceProof) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.NonExistenceProof.left":
		if x.Left == nil {
			x.Left = new(ExistenceProof)
		}
		return protoreflect.ValueOfMessage(x.Left.ProtoReflect())
	case "ics23.NonExistenceProof.right":
		if x.Right == nil {
			x.Right = new(ExistenceProof)
		}
		return protoreflect.ValueOfMessage(x.Right.ProtoReflect())
	case "ics23.NonExistenceProof.key":
		panic(fmt.Errorf("field key of message ics23.NonExistenceProof is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.NonExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.NonExistenceProof does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_NonExistenceProof) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.NonExistenceProof.key":
		return protoreflect.ValueOfBytes(nil)
	case "ics23.NonExistenceProof.left":
		m := new(ExistenceProof)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "ics23.NonExistenceProof.right":
		m := new(ExistenceProof)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.NonExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.NonExistenceProof does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_NonExistenceProof) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ics23.NonExistenceProof", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_NonExistenceProof) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NonExistenceProof) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_NonExistenceProof) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_NonExistenceProof) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*NonExistenceProof)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Key)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Left != nil {
			l = options.Size(x.Left)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Right != nil {
			l = options.Size(x.Right)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*NonExistenceProof)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Right != nil {
			encoded, err := options.Marshal(x.Right)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if x.Left != nil {
			encoded, err := options.Marshal(x.Left)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Key) > 0 {
			i -= len(x.Key)
			copy(dAtA[i:], x.Key)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Key)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*NonExistenceProof)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: NonExistenceProof: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: NonExistenceProof: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Key = append(x.Key[:0], dAtA[iNdEx:postIndex]...)
				if x.Key == nil {
					x.Key = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Left == nil {
					x.Left = &ExistenceProof{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Left); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Right == nil {
					x.Right = &ExistenceProof{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Right); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_CommitmentProof            protoreflect.MessageDescriptor
	fd_CommitmentProof_exist      protoreflect.FieldDescriptor
	fd_CommitmentProof_nonexist   protoreflect.FieldDescriptor
	fd_CommitmentProof_batch      protoreflect.FieldDescriptor
	fd_CommitmentProof_compressed protoreflect.FieldDescriptor
)

func init() {
	file_proofs_proto_init()
	md_CommitmentProof = File_proofs_proto.Messages().ByName("CommitmentProof")
	fd_CommitmentProof_exist = md_CommitmentProof.Fields().ByName("exist")
	fd_CommitmentProof_nonexist = md_CommitmentProof.Fields().ByName("nonexist")
	fd_CommitmentProof_batch = md_CommitmentProof.Fields().ByName("batch")
	fd_CommitmentProof_compressed = md_CommitmentProof.Fields().ByName("compressed")
}

var _ protoreflect.Message = (*fastReflection_CommitmentProof)(nil)

type fastReflection_CommitmentProof CommitmentProof

func (x *CommitmentProof) ProtoReflect() protoreflect.Message {
	return (*fastReflection_CommitmentProof)(x)
}

func (x *CommitmentProof) slowProtoReflect() protoreflect.Message {
	mi := &file_proofs_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_CommitmentProof_messageType fastReflection_CommitmentProof_messageType
var _ protoreflect.MessageType = fastReflection_CommitmentProof_messageType{}

type fastReflection_CommitmentProof_messageType struct{}

func (x fastReflection_CommitmentProof_messageType) Zero() protoreflect.Message {
	return (*fastReflection_CommitmentProof)(nil)
}
func (x fastReflection_CommitmentProof_messageType) New() protoreflect.Message {
	return new(fastReflection_CommitmentProof)
}
func (x fastReflection_CommitmentProof_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_CommitmentProof
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_CommitmentProof) Descriptor() protoreflect.MessageDescriptor {
	return md_CommitmentProof
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_CommitmentProof) Type() protoreflect.MessageType {
	return _fastReflection_CommitmentProof_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_CommitmentProof) New() protoreflect.Message {
	return new(fastReflection_CommitmentProof)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_CommitmentProof) Interface() protoreflect.ProtoMessage {
	return (*CommitmentProof)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_CommitmentProof) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Proof != nil {
		switch o := x.Proof.(type) {
		case *CommitmentProof_Exist:
			v := o.Exist
			value := protoreflect.ValueOfMessage(v.ProtoReflect())
			if !f(fd_CommitmentProof_exist, value) {
				return
			}
		case *CommitmentProof_Nonexist:
			v := o.Nonexist
			value := protoreflect.ValueOfMessage(v.ProtoReflect())
			if !f(fd_CommitmentProof_nonexist, value) {
				return
			}
		case *CommitmentProof_Batch:
			v := o.Batch
			value := protoreflect.ValueOfMessage(v.ProtoReflect())
			if !f(fd_CommitmentProof_batch, value) {
				return
			}
		case *CommitmentProof_Compressed:
			v := o.Compressed
			value := protoreflect.ValueOfMessage(v.ProtoReflect())
			if !f(fd_CommitmentProof_compressed, value) {
				return
			}
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_CommitmentProof) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ics23.CommitmentProof.exist":
		if x.Proof == nil {
			return false
		} else if _, ok := x.Proof.(*CommitmentProof_Exist); ok {
			return true
		} else {
			return false
		}
	case "ics23.CommitmentProof.nonexist":
		if x.Proof == nil {
			return false
		} else if _, ok := x.Proof.(*CommitmentProof_Nonexist); ok {
			return true
		} else {
			return false
		}
	case "ics23.CommitmentProof.batch":
		if x.Proof == nil {
			return false
		} else if _, ok := x.Proof.(*CommitmentProof_Batch); ok {
			return true
		} else {
			return false
		}
	case "ics23.CommitmentProof.compressed":
		if x.Proof == nil {
			return false
		} else if _, ok := x.Proof.(*CommitmentProof_Compressed); ok {
			return true
		} else {
			return false
		}
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CommitmentProof"))
		}
		panic(fmt.Errorf("message ics23.CommitmentProof does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CommitmentProof) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ics23.CommitmentProof.exist":
		x.Proof = nil
	case "ics23.CommitmentProof.nonexist":
		x.Proof = nil
	case "ics23.CommitmentProof.batch":
		x.Proof = nil
	case "ics23.CommitmentProof.compressed":
		x.Proof = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CommitmentProof"))
		}
		panic(fmt.Errorf("message ics23.CommitmentProof does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_CommitmentProof) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ics23.CommitmentProof.exist":
		if x.Proof == nil {
			return protoreflect.ValueOfMessage((*ExistenceProof)(nil).ProtoReflect())
		} else if v, ok := x.Proof.(*CommitmentProof_Exist); ok {
			return protoreflect.ValueOfMessage(v.Exist.ProtoReflect())
		} else {
			return protoreflect.ValueOfMessage((*ExistenceProof)(nil).ProtoReflect())
		}
	case "ics23.CommitmentProof.nonexist":
		if x.Proof == nil {
			return protoreflect.ValueOfMessage((*NonExistenceProof)(nil).ProtoReflect())
		} else if v, ok := x.Proof.(*CommitmentProof_Nonexist); ok {
			return protoreflect.ValueOfMessage(v.Nonexist.ProtoReflect())
		} else {
			return protoreflect.ValueOfMessage((*NonExistenceProof)(nil).ProtoReflect())
		}
	case "ics23.CommitmentProof.batch":
		if x.Proof == nil {
			return protoreflect.ValueOfMessage((*BatchProof)(nil).ProtoReflect())
		} else if v, ok := x.Proof.(*CommitmentProof_Batch); ok {
			return protoreflect.ValueOfMessage(v.Batch.ProtoReflect())
		} else {
			return protoreflect.ValueOfMessage((*BatchProof)(nil).ProtoReflect())
		}
	case "ics23.CommitmentProof.compressed":
		if x.Proof == nil {
			return protoreflect.ValueOfMessage((*CompressedBatchProof)(nil).ProtoReflect())
		} else if v, ok := x.Proof.(*CommitmentProof_Compressed); ok {
			return protoreflect.ValueOfMessage(v.Compressed.ProtoReflect())
		} else {
			return protoreflect.ValueOfMessage((*CompressedBatchProof)(nil).ProtoReflect())
		}
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CommitmentProof"))
		}
		panic(fmt.Errorf("message ics23.CommitmentProof does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CommitmentProof) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ics23.CommitmentProof.exist":
		cv := value.Message().Interface().(*ExistenceProof)
		x.Proof = &CommitmentProof_Exist{Exist: cv}
	case "ics23.CommitmentProof.nonexist":
		cv := value.Message().Interface().(*NonExistenceProof)
		x.Proof = &CommitmentProof_Nonexist{Nonexist: cv}
	case "ics23.CommitmentProof.batch":
		cv := value.Message().Interface().(*BatchProof)
		x.Proof = &CommitmentProof_Batch{Batch: cv}
	case "ics23.CommitmentProof.compressed":
		cv := value.Message().Interface().(*CompressedBatchProof)
		x.Proof = &CommitmentProof_Compressed{Compressed: cv}
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CommitmentProof"))
		}
		panic(fmt.Errorf("message ics23.CommitmentProof does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CommitmentProof) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.CommitmentProof.exist":
		if x.Proof == nil {
			value := &ExistenceProof{}
			oneofValue := &CommitmentProof_Exist{Exist: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
		switch m := x.Proof.(type) {
		case *CommitmentProof_Exist:
			return protoreflect.ValueOfMessage(m.Exist.ProtoReflect())
		default:
			value := &ExistenceProof{}
			oneofValue := &CommitmentProof_Exist{Exist: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
	case "ics23.CommitmentProof.nonexist":
		if x.Proof == nil {
			value := &NonExistenceProof{}
			oneofValue := &CommitmentProof_Nonexist{Nonexist: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
		switch m := x.Proof.(type) {
		case *CommitmentProof_Nonexist:
			return protoreflect.ValueOfMessage(m.Nonexist.ProtoReflect())
		default:
			value := &NonExistenceProof{}
			oneofValue := &CommitmentProof_Nonexist{Nonexist: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
	case "ics23.CommitmentProof.batch":
		if x.Proof == nil {
			value := &BatchProof{}
			oneofValue := &CommitmentProof_Batch{Batch: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
		switch m := x.Proof.(type) {
		case *CommitmentProof_Batch:
			return protoreflect.ValueOfMessage(m.Batch.ProtoReflect())
		default:
			value := &BatchProof{}
			oneofValue := &CommitmentProof_Batch{Batch: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
	case "ics23.CommitmentProof.compressed":
		if x.Proof == nil {
			value := &CompressedBatchProof{}
			oneofValue := &CommitmentProof_Compressed{Compressed: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
		switch m := x.Proof.(type) {
		case *CommitmentProof_Compressed:
			return protoreflect.ValueOfMessage(m.Compressed.ProtoReflect())
		default:
			value := &CompressedBatchProof{}
			oneofValue := &CommitmentProof_Compressed{Compressed: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CommitmentProof"))
		}
		panic(fmt.Errorf("message ics23.CommitmentProof does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_CommitmentProof) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.CommitmentProof.exist":
		value := &ExistenceProof{}
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "ics23.CommitmentProof.nonexist":
		value := &NonExistenceProof{}
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "ics23.CommitmentProof.batch":
		value := &BatchProof{}
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "ics23.CommitmentProof.compressed":
		value := &CompressedBatchProof{}
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CommitmentProof"))
		}
		panic(fmt.Errorf("message ics23.CommitmentProof does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_CommitmentProof) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	case "ics23.CommitmentProof.proof":
		if x.Proof == nil {
			return nil
		}
		switch x.Proof.(type) {
		case *CommitmentProof_Exist:
			return x.Descriptor().Fields().ByName("exist")
		case *CommitmentProof_Nonexist:
			return x.Descriptor().Fields().ByName("nonexist")
		case *CommitmentProof_Batch:
			return x.Descriptor().Fields().ByName("batch")
		case *CommitmentProof_Compressed:
			return x.Descriptor().Fields().ByName("compressed")
		}
	default:
		panic(fmt.Errorf("%s is not a oneof field in ics23.CommitmentProof", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_CommitmentProof) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CommitmentProof) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_CommitmentProof) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_CommitmentProof) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*CommitmentProof)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		switch x := x.Proof.(type) {
		case *CommitmentProof_Exist:
			if x == nil {
				break
			}
			l = options.Size(x.Exist)
			n += 1 + l + runtime.Sov(uint64(l))
		case *CommitmentProof_Nonexist:
			if x == nil {
				break
			}
			l = options.Size(x.Nonexist)
			n += 1 + l + runtime.Sov(uint64(l))
		case *CommitmentProof_Batch:
			if x == nil {
				break
			}
			l = options.Size(x.Batch)
			n += 1 + l + runtime.Sov(uint64(l))
		case *CommitmentProof_Compressed:
			if x == nil {
				break
			}
			l = options.Size(x.Compressed)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*CommitmentProof)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		switch x := x.Proof.(type) {
		case *CommitmentProof_Exist:
			encoded, err := options.Marshal(x.Exist)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		case *CommitmentProof_Nonexist:
			encoded, err := options.Marshal(x.Nonexist)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		case *CommitmentProof_Batch:
			encoded, err := options.Marshal(x.Batch)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		case *CommitmentProof_Compressed:
			encoded, err := options.Marshal(x.Compressed)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*CommitmentProof)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CommitmentProof: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CommitmentProof: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Exist", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				v := &ExistenceProof{}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], v); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				x.Proof = &CommitmentProof_Exist{v}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonexist", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				v := &NonExistenceProof{}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], v); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				x.Proof = &CommitmentProof_Nonexist{v}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				v := &BatchProof{}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], v); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				x.Proof = &CommitmentProof_Batch{v}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Compressed", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				v := &CompressedBatchProof{}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], v); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				x.Proof = &CommitmentProof_Compressed{v}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_LeafOp               protoreflect.MessageDescriptor
	fd_LeafOp_hash          protoreflect.FieldDescriptor
	fd_LeafOp_prehash_key   protoreflect.FieldDescriptor
	fd_LeafOp_prehash_value protoreflect.FieldDescriptor
	fd_LeafOp_length        protoreflect.FieldDescriptor
	fd_LeafOp_prefix        protoreflect.FieldDescriptor
)

func init() {
	file_proofs_proto_init()
	md_LeafOp = File_proofs_proto.Messages().ByName("LeafOp")
	fd_LeafOp_hash = md_LeafOp.Fields().ByName("hash")
	fd_LeafOp_prehash_key = md_LeafOp.Fields().ByName("prehash_key")
	fd_LeafOp_prehash_value = md_LeafOp.Fields().ByName("prehash_value")
	fd_LeafOp_length = md_LeafOp.Fields().ByName("length")
	fd_LeafOp_prefix = md_LeafOp.Fields().ByName("prefix")
}

var _ protoreflect.Message = (*fastReflection_LeafOp)(nil)

type fastReflection_LeafOp LeafOp

func (x *LeafOp) ProtoReflect() protoreflect.Message {
	return (*fastReflection_LeafOp)(x)
}

func (x *LeafOp) slowProtoReflect() protoreflect.Message {
	mi := &file_proofs_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_LeafOp_messageType fastReflection_LeafOp_messageType
var _ protoreflect.MessageType = fastReflection_LeafOp_messageType{}

type fastReflection_LeafOp_messageType struct{}

func (x fastReflection_LeafOp_messageType) Zero() protoreflect.Message {
	return (*fastReflection_LeafOp)(nil)
}
func (x fastReflection_LeafOp_messageType) New() protoreflect.Message {
	return new(fastReflection_LeafOp)
}
func (x fastReflection_LeafOp_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_LeafOp
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_LeafOp) Descriptor() protoreflect.MessageDescriptor {
	return md_LeafOp
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_LeafOp) Type() protoreflect.MessageType {
	return _fastReflection_LeafOp_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_LeafOp) New() protoreflect.Message {
	return new(fastReflection_LeafOp)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_LeafOp) Interface() protoreflect.ProtoMessage {
	return (*LeafOp)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_LeafOp) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Hash != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Hash))
		if !f(fd_LeafOp_hash, value) {
			return
		}
	}
	if x.PrehashKey != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.PrehashKey))
		if !f(fd_LeafOp_prehash_key, value) {
			return
		}
	}
	if x.PrehashValue != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.PrehashValue))
		if !f(fd_LeafOp_prehash_value, value) {
			return
		}
	}
	if x.Length != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Length))
		if !f(fd_LeafOp_length, value) {
			return
		}
	}
	if len(x.Prefix) != 0 {
		value := protoreflect.ValueOfBytes(x.Prefix)
		if !f(fd_LeafOp_prefix, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_LeafOp) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ics23.LeafOp.hash":
		return x.Hash != 0
	case "ics23.LeafOp.prehash_key":
		return x.PrehashKey != 0
	case "ics23.LeafOp.prehash_value":
		return x.PrehashValue != 0
	case "ics23.LeafOp.length":
		return x.Length != 0
	case "ics23.LeafOp.prefix":
		return len(x.Prefix) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.LeafOp"))
		}
		panic(fmt.Errorf("message ics23.LeafOp does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LeafOp) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ics23.LeafOp.hash":
		x.Hash = 0
	case "ics23.LeafOp.prehash_key":
		x.PrehashKey = 0
	case "ics23.LeafOp.prehash_value":
		x.PrehashValue = 0
	case "ics23.LeafOp.length":
		x.Length = 0
	case "ics23.LeafOp.prefix":
		x.Prefix = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.LeafOp"))
		}
		panic(fmt.Errorf("message ics23.LeafOp does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_LeafOp) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ics23.LeafOp.hash":
		value := x.Hash
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "ics23.LeafOp.prehash_key":
		value := x.PrehashKey
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "ics23.LeafOp.prehash_value":
		value := x.PrehashValue
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "ics23.LeafOp.length":
		value := x.Length
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "ics23.LeafOp.prefix":
		value := x.Prefix
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.LeafOp"))
		}
		panic(fmt.Errorf("message ics23.LeafOp does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LeafOp) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ics23.LeafOp.hash":
		x.Hash = (HashOp)(value.Enum())
	case "ics23.LeafOp.prehash_key":
		x.PrehashKey = (HashOp)(value.Enum())
	case "ics23.LeafOp.prehash_value":
		x.PrehashValue = (HashOp)(value.Enum())
	case "ics23.LeafOp.length":
		x.Length = (LengthOp)(value.Enum())
	case "ics23.LeafOp.prefix":
		x.Prefix = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.LeafOp"))
		}
		panic(fmt.Errorf("message ics23.LeafOp does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LeafOp) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.LeafOp.hash":
		panic(fmt.Errorf("field hash of message ics23.LeafOp is not mutable"))
	case "ics23.LeafOp.prehash_key":
		panic(fmt.Errorf("field prehash_key of message ics23.LeafOp is not mutable"))
	case "ics23.LeafOp.prehash_value":
		panic(fmt.Errorf("field prehash_value of message ics23.LeafOp is not mutable"))
	case "ics23.LeafOp.length":
		panic(fmt.Errorf("field length of message ics23.LeafOp is not mutable"))
	case "ics23.LeafOp.prefix":
		panic(fmt.Errorf("field prefix of message ics23.LeafOp is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.LeafOp"))
		}
		panic(fmt.Errorf("message ics23.LeafOp does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_LeafOp) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.LeafOp.hash":
		return protoreflect.ValueOfEnum(0)
	case "ics23.LeafOp.prehash_key":
		return protoreflect.ValueOfEnum(0)
	case "ics23.LeafOp.prehash_value":
		return protoreflect.ValueOfEnum(0)
	case "ics23.LeafOp.length":
		return protoreflect.ValueOfEnum(0)
	case "ics23.LeafOp.prefix":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.LeafOp"))
		}
		panic(fmt.Errorf("message ics23.LeafOp does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_LeafOp) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ics23.LeafOp", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_LeafOp) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LeafOp) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_LeafOp) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_LeafOp) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*LeafOp)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Hash != 0 {
			n += 1 + runtime.Sov(uint64(x.Hash))
		}
		if x.PrehashKey != 0 {
			n += 1 + runtime.Sov(uint64(x.PrehashKey))
		}
		if x.PrehashValue != 0 {
			n += 1 + runtime.Sov(uint64(x.PrehashValue))
		}
		if x.Length != 0 {
			n += 1 + runtime.Sov(uint64(x.Length))
		}
		l = len(x.Prefix)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*LeafOp)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Prefix) > 0 {
			i -= len(x.Prefix)
			copy(dAtA[i:], x.Prefix)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Prefix)))
			i--
			dAtA[i] = 0x2a
		}
		if x.Length != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Length))
			i--
			dAtA[i] = 0x20
		}
		if x.PrehashValue != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PrehashValue))
			i--
			dAtA[i] = 0x18
		}
		if x.PrehashKey != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PrehashKey))
			i--
			dAtA[i] = 0x10
		}
		if x.Hash != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Hash))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*LeafOp)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: LeafOp: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: LeafOp: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
				}
				x.Hash = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Hash |= HashOp(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrehashKey", wireType)
				}
				x.PrehashKey = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PrehashKey |= HashOp(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrehashValue", wireType)
				}
				x.PrehashValue = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PrehashValue |= HashOp(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
				}
				x.Length = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Length |= LengthOp(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Prefix = append(x.Prefix[:0], dAtA[iNdEx:postIndex]...)
				if x.Prefix == nil {
					x.Prefix = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_InnerOp        protoreflect.MessageDescriptor
	fd_InnerOp_hash   protoreflect.FieldDescriptor
	fd_InnerOp_prefix protoreflect.FieldDescriptor
	fd_InnerOp_suffix protoreflect.FieldDescriptor
)

func init() {
	file_proofs_proto_init()
	md_InnerOp = File_proofs_proto.Messages().ByName("InnerOp")
	fd_InnerOp_hash = md_InnerOp.Fields().ByName("hash")
	fd_InnerOp_prefix = md_InnerOp.Fields().ByName("prefix")
	fd_InnerOp_suffix = md_InnerOp.Fields().ByName("suffix")
}

var _ protoreflect.Message = (*fastReflection_InnerOp)(nil)

type fastReflection_InnerOp InnerOp

func (x *InnerOp) ProtoReflect() protoreflect.Message {
	return (*fastReflection_InnerOp)(x)
}

func (x *InnerOp) slowProtoReflect() protoreflect.Message {
	mi := &file_proofs_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_InnerOp_messageType fastReflection_InnerOp_messageType
var _ protoreflect.MessageType = fastReflection_InnerOp_messageType{}

type fastReflection_InnerOp_messageType struct{}

func (x fastReflection_InnerOp_messageType) Zero() protoreflect.Message {
	return (*fastReflection_InnerOp)(nil)
}
func (x fastReflection_InnerOp_messageType) New() protoreflect.Message {
	return new(fastReflection_InnerOp)
}
func (x fastReflection_InnerOp_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_InnerOp
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_InnerOp) Descriptor() protoreflect.MessageDescriptor {
	return md_InnerOp
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_InnerOp) Type() protoreflect.MessageType {
	return _fastReflection_InnerOp_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_InnerOp) New() protoreflect.Message {
	return new(fastReflection_InnerOp)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_InnerOp) Interface() protoreflect.ProtoMessage {
	return (*InnerOp)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_InnerOp) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Hash != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Hash))
		if !f(fd_InnerOp_hash, value) {
			return
		}
	}
	if len(x.Prefix) != 0 {
		value := protoreflect.ValueOfBytes(x.Prefix)
		if !f(fd_InnerOp_prefix, value) {
			return
		}
	}
	if len(x.Suffix) != 0 {
		value := protoreflect.ValueOfBytes(x.Suffix)
		if !f(fd_InnerOp_suffix, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_InnerOp) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ics23.InnerOp.hash":
		return x.Hash != 0
	case "ics23.InnerOp.prefix":
		return len(x.Prefix) != 0
	case "ics23.InnerOp.suffix":
		return len(x.Suffix) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.InnerOp"))
		}
		panic(fmt.Errorf("message ics23.InnerOp does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_InnerOp) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ics23.InnerOp.hash":
		x.Hash = 0
	case "ics23.InnerOp.prefix":
		x.Prefix = nil
	case "ics23.InnerOp.suffix":
		x.Suffix = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.InnerOp"))
		}
		panic(fmt.Errorf("message ics23.InnerOp does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_InnerOp) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ics23.InnerOp.hash":
		value := x.Hash
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "ics23.InnerOp.prefix":
		value := x.Prefix
		return protoreflect.ValueOfBytes(value)
	case "ics23.InnerOp.suffix":
		value := x.Suffix
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.InnerOp"))
		}
		panic(fmt.Errorf("message ics23.InnerOp does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_InnerOp) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ics23.InnerOp.hash":
		x.Hash = (HashOp)(value.Enum())
	case "ics23.InnerOp.prefix":
		x.Prefix = value.Bytes()
	case "ics23.InnerOp.suffix":
		x.Suffix = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.InnerOp"))
		}
		panic(fmt.Errorf("message ics23.InnerOp does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_InnerOp) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.InnerOp.hash":
		panic(fmt.Errorf("field hash of message ics23.InnerOp is not mutable"))
	case "ics23.InnerOp.prefix":
		panic(fmt.Errorf("field prefix of message ics23.InnerOp is not mutable"))
	case "ics23.InnerOp.suffix":
		panic(fmt.Errorf("field suffix of message ics23.InnerOp is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.InnerOp"))
		}
		panic(fmt.Errorf("message ics23.InnerOp does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_InnerOp) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.InnerOp.hash":
		return protoreflect.ValueOfEnum(0)
	case "ics23.InnerOp.prefix":
		return protoreflect.ValueOfBytes(nil)
	case "ics23.InnerOp.suffix":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.InnerOp"))
		}
		panic(fmt.Errorf("message ics23.InnerOp does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_InnerOp) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ics23.InnerOp", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_InnerOp) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_InnerOp) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_InnerOp) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_InnerOp) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*InnerOp)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Hash != 0 {
			n += 1 + runtime.Sov(uint64(x.Hash))
		}
		l = len(x.Prefix)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Suffix)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*InnerOp)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Suffix) > 0 {
			i -= len(x.Suffix)
			copy(dAtA[i:], x.Suffix)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Suffix)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Prefix) > 0 {
			i -= len(x.Prefix)
			copy(dAtA[i:], x.Prefix)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Prefix)))
			i--
			dAtA[i] = 0x12
		}
		if x.Hash != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Hash))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*InnerOp)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: InnerOp: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: InnerOp: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
				}
				x.Hash = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Hash |= HashOp(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Prefix = append(x.Prefix[:0], dAtA[iNdEx:postIndex]...)
				if x.Prefix == nil {
					x.Prefix = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Suffix", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Suffix = append(x.Suffix[:0], dAtA[iNdEx:postIndex]...)
				if x.Suffix == nil {
					x.Suffix = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_ProofSpec            protoreflect.MessageDescriptor
	fd_ProofSpec_leaf_spec  protoreflect.FieldDescriptor
	fd_ProofSpec_inner_spec protoreflect.FieldDescriptor
	fd_ProofSpec_max_depth  protoreflect.FieldDescriptor
	fd_ProofSpec_min_depth  protoreflect.FieldDescriptor
)

func init() {
	file_proofs_proto_init()
	md_ProofSpec = File_proofs_proto.Messages().ByName("ProofSpec")
	fd_ProofSpec_leaf_spec = md_ProofSpec.Fields().ByName("leaf_spec")
	fd_ProofSpec_inner_spec = md_ProofSpec.Fields().ByName("inner_spec")
	fd_ProofSpec_max_depth = md_ProofSpec.Fields().ByName("max_depth")
	fd_ProofSpec_min_depth = md_ProofSpec.Fields().ByName("min_depth")
}

var _ protoreflect.Message = (*fastReflection_ProofSpec)(nil)

type fastReflection_ProofSpec ProofSpec

func (x *ProofSpec) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ProofSpec)(x)
}

func (x *ProofSpec) slowProtoReflect() protoreflect.Message {
	mi := &file_proofs_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ProofSpec_messageType fastReflection_ProofSpec_messageType
var _ protoreflect.MessageType = fastReflection_ProofSpec_messageType{}

type fastReflection_ProofSpec_messageType struct{}

func (x fastReflection_ProofSpec_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ProofSpec)(nil)
}
func (x fastReflection_ProofSpec_messageType) New() protoreflect.Message {
	return new(fastReflection_ProofSpec)
}
func (x fastReflection_ProofSpec_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ProofSpec
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ProofSpec) Descriptor() protoreflect.MessageDescriptor {
	return md_ProofSpec
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ProofSpec) Type() protoreflect.MessageType {
	return _fastReflection_ProofSpec_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ProofSpec) New() protoreflect.Message {
	return new(fastReflection_ProofSpec)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ProofSpec) Interface() protoreflect.ProtoMessage {
	return (*ProofSpec)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ProofSpec) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.LeafSpec != nil {
		value := protoreflect.ValueOfMessage(x.LeafSpec.ProtoReflect())
		if !f(fd_ProofSpec_leaf_spec, value) {
			return
		}
	}
	if x.InnerSpec != nil {
		value := protoreflect.ValueOfMessage(x.InnerSpec.ProtoReflect())
		if !f(fd_ProofSpec_inner_spec, value) {
			return
		}
	}
	if x.MaxDepth != int32(0) {
		value := protoreflect.ValueOfInt32(x.MaxDepth)
		if !f(fd_ProofSpec_max_depth, value) {
			return
		}
	}
	if x.MinDepth != int32(0) {
		value := protoreflect.ValueOfInt32(x.MinDepth)
		if !f(fd_ProofSpec_min_depth, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ProofSpec) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ics23.ProofSpec.leaf_spec":
		return x.LeafSpec != nil
	case "ics23.ProofSpec.inner_spec":
		return x.InnerSpec != nil
	case "ics23.ProofSpec.max_depth":
		return x.MaxDepth != int32(0)
	case "ics23.ProofSpec.min_depth":
		return x.MinDepth != int32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.ProofSpec"))
		}
		panic(fmt.Errorf("message ics23.ProofSpec does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ProofSpec) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ics23.ProofSpec.leaf_spec":
		x.LeafSpec = nil
	case "ics23.ProofSpec.inner_spec":
		x.InnerSpec = nil
	case "ics23.ProofSpec.max_depth":
		x.MaxDepth = int32(0)
	case "ics23.ProofSpec.min_depth":
		x.MinDepth = int32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.ProofSpec"))
		}
		panic(fmt.Errorf("message ics23.ProofSpec does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ProofSpec) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ics23.ProofSpec.leaf_spec":
		value := x.LeafSpec
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "ics23.ProofSpec.inner_spec":
		value := x.InnerSpec
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "ics23.ProofSpec.max_depth":
		value := x.MaxDepth
		return protoreflect.ValueOfInt32(value)
	case "ics23.ProofSpec.min_depth":
		value := x.MinDepth
		return protoreflect.ValueOfInt32(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.ProofSpec"))
		}
		panic(fmt.Errorf("message ics23.ProofSpec does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ProofSpec) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ics23.ProofSpec.leaf_spec":
		x.LeafSpec = value.Message().Interface().(*LeafOp)
	case "ics23.ProofSpec.inner_spec":
		x.InnerSpec = value.Message().Interface().(*InnerSpec)
	case "ics23.ProofSpec.max_depth":
		x.MaxDepth = int32(value.Int())
	case "ics23.ProofSpec.min_depth":
		x.MinDepth = int32(value.Int())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.ProofSpec"))
		}
		panic(fmt.Errorf("message ics23.ProofSpec does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ProofSpec) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.ProofSpec.leaf_spec":
		if x.LeafSpec == nil {
			x.LeafSpec = new(LeafOp)
		}
		return protoreflect.ValueOfMessage(x.LeafSpec.ProtoReflect())
	case "ics23.ProofSpec.inner_spec":
		if x.InnerSpec == nil {
			x.InnerSpec = new(InnerSpec)
		}
		return protoreflect.ValueOfMessage(x.InnerSpec.ProtoReflect())
	case "ics23.ProofSpec.max_depth":
		panic(fmt.Errorf("field max_depth of message ics23.ProofSpec is not mutable"))
	case "ics23.ProofSpec.min_depth":
		panic(fmt.Errorf("field min_depth of message ics23.ProofSpec is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.ProofSpec"))
		}
		panic(fmt.Errorf("message ics23.ProofSpec does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ProofSpec) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.ProofSpec.leaf_spec":
		m := new(LeafOp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "ics23.ProofSpec.inner_spec":
		m := new(InnerSpec)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "ics23.ProofSpec.max_depth":
		return protoreflect.ValueOfInt32(int32(0))
	case "ics23.ProofSpec.min_depth":
		return protoreflect.ValueOfInt32(int32(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.ProofSpec"))
		}
		panic(fmt.Errorf("message ics23.ProofSpec does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ProofSpec) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ics23.ProofSpec", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ProofSpec) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ProofSpec) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ProofSpec) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ProofSpec) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ProofSpec)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.LeafSpec != nil {
			l = options.Size(x.LeafSpec)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.InnerSpec != nil {
			l = options.Size(x.InnerSpec)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.MaxDepth != 0 {
			n += 1 + runtime.Sov(uint64(x.MaxDepth))
		}
		if x.MinDepth != 0 {
			n += 1 + runtime.Sov(uint64(x.MinDepth))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ProofSpec)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.MinDepth != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MinDepth))
			i--
			dAtA[i] = 0x20
		}
		if x.MaxDepth != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MaxDepth))
			i--
			dAtA[i] = 0x18
		}
		if x.InnerSpec != nil {
			encoded, err := options.Marshal(x.InnerSpec)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if x.LeafSpec != nil {
			encoded, err := options.Marshal(x.LeafSpec)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ProofSpec)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ProofSpec: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ProofSpec: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LeafSpec", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.LeafSpec == nil {
					x.LeafSpec = &LeafOp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.LeafSpec); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field InnerSpec", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.InnerSpec == nil {
					x.InnerSpec = &InnerSpec{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.InnerSpec); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxDepth", wireType)
				}
				x.MaxDepth = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MaxDepth |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MinDepth", wireType)
				}
				x.MinDepth = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MinDepth |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_InnerSpec_1_list)(nil)

type _InnerSpec_1_list struct {
	list *[]int32
}

func (x *_InnerSpec_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_InnerSpec_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfInt32((*x.list)[i])
}

func (x *_InnerSpec_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Int()
	concreteValue := (int32)(valueUnwrapped)
	(*x.list)[i] = concreteValue
}

func (x *_InnerSpec_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Int()
	concreteValue := (int32)(valueUnwrapped)
	*x.list = append(*x.list, concreteValue)
}

func (x *_InnerSpec_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message InnerSpec at list field ChildOrder as it is not of Message kind"))
}

func (x *_InnerSpec_1_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_InnerSpec_1_list) NewElement() protoreflect.Value {
	v := int32(0)
	return protoreflect.ValueOfInt32(v)
}

func (x *_InnerSpec_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_InnerSpec                   protoreflect.MessageDescriptor
	fd_InnerSpec_child_order       protoreflect.FieldDescriptor
	fd_InnerSpec_child_size        protoreflect.FieldDescriptor
	fd_InnerSpec_min_prefix_length protoreflect.FieldDescriptor
	fd_InnerSpec_max_prefix_length protoreflect.FieldDescriptor
	fd_InnerSpec_empty_child       protoreflect.FieldDescriptor
	fd_InnerSpec_hash              protoreflect.FieldDescriptor
)

func init() {
	file_proofs_proto_init()
	md_InnerSpec = File_proofs_proto.Messages().ByName("InnerSpec")
	fd_InnerSpec_child_order = md_InnerSpec.Fields().ByName("child_order")
	fd_InnerSpec_child_size = md_InnerSpec.Fields().ByName("child_size")
	fd_InnerSpec_min_prefix_length = md_InnerSpec.Fields().ByName("min_prefix_length")
	fd_InnerSpec_max_prefix_length = md_InnerSpec.Fields().ByName("max_prefix_length")
	fd_InnerSpec_empty_child = md_InnerSpec.Fields().ByName("empty_child")
	fd_InnerSpec_hash = md_InnerSpec.Fields().ByName("hash")
}

var _ protoreflect.Message = (*fastReflection_InnerSpec)(nil)

type fastReflection_InnerSpec InnerSpec

func (x *InnerSpec) ProtoReflect() protoreflect.Message {
	return (*fastReflection_InnerSpec)(x)
}

func (x *InnerSpec) slowProtoReflect() protoreflect.Message {
	mi := &file_proofs_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_InnerSpec_messageType fastReflection_InnerSpec_messageType
var _ protoreflect.MessageType = fastReflection_InnerSpec_messageType{}

type fastReflection_InnerSpec_messageType struct{}

func (x fastReflection_InnerSpec_messageType) Zero() protoreflect.Message {
	return (*fastReflection_InnerSpec)(nil)
}
func (x fastReflection_InnerSpec_messageType) New() protoreflect.Message {
	return new(fastReflection_InnerSpec)
}
func (x fastReflection_InnerSpec_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_InnerSpec
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_InnerSpec) Descriptor() protoreflect.MessageDescriptor {
	return md_InnerSpec
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_InnerSpec) Type() protoreflect.MessageType {
	return _fastReflection_InnerSpec_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_InnerSpec) New() protoreflect.Message {
	return new(fastReflection_InnerSpec)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_InnerSpec) Interface() protoreflect.ProtoMessage {
	return (*InnerSpec)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_InnerSpec) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.ChildOrder) != 0 {
		value := protoreflect.ValueOfList(&_InnerSpec_1_list{list: &x.ChildOrder})
		if !f(fd_InnerSpec_child_order, value) {
			return
		}
	}
	if x.ChildSize != int32(0) {
		value := protoreflect.ValueOfInt32(x.ChildSize)
		if !f(fd_InnerSpec_child_size, value) {
			return
		}
	}
	if x.MinPrefixLength != int32(0) {
		value := protoreflect.ValueOfInt32(x.MinPrefixLength)
		if !f(fd_InnerSpec_min_prefix_length, value) {
			return
		}
	}
	if x.MaxPrefixLength != int32(0) {
		value := protoreflect.ValueOfInt32(x.MaxPrefixLength)
		if !f(fd_InnerSpec_max_prefix_length, value) {
			return
		}
	}
	if len(x.EmptyChild) != 0 {
		value := protoreflect.ValueOfBytes(x.EmptyChild)
		if !f(fd_InnerSpec_empty_child, value) {
			return
		}
	}
	if x.Hash != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Hash))
		if !f(fd_InnerSpec_hash, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_InnerSpec) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ics23.InnerSpec.child_order":
		return len(x.ChildOrder) != 0
	case "ics23.InnerSpec.child_size":
		return x.ChildSize != int32(0)
	case "ics23.InnerSpec.min_prefix_length":
		return x.MinPrefixLength != int32(0)
	case "ics23.InnerSpec.max_prefix_length":
		return x.MaxPrefixLength != int32(0)
	case "ics23.InnerSpec.empty_child":
		return len(x.EmptyChild) != 0
	case "ics23.InnerSpec.hash":
		return x.Hash != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.InnerSpec"))
		}
		panic(fmt.Errorf("message ics23.InnerSpec does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_InnerSpec) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ics23.InnerSpec.child_order":
		x.ChildOrder = nil
	case "ics23.InnerSpec.child_size":
		x.ChildSize = int32(0)
	case "ics23.InnerSpec.min_prefix_length":
		x.MinPrefixLength = int32(0)
	case "ics23.InnerSpec.max_prefix_length":
		x.MaxPrefixLength = int32(0)
	case "ics23.InnerSpec.empty_child":
		x.EmptyChild = nil
	case "ics23.InnerSpec.hash":
		x.Hash = 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.InnerSpec"))
		}
		panic(fmt.Errorf("message ics23.InnerSpec does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_InnerSpec) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ics23.InnerSpec.child_order":
		if len(x.ChildOrder) == 0 {
			return protoreflect.ValueOfList(&_InnerSpec_1_list{})
		}
		listValue := &_InnerSpec_1_list{list: &x.ChildOrder}
		return protoreflect.ValueOfList(listValue)
	case "ics23.InnerSpec.child_size":
		value := x.ChildSize
		return protoreflect.ValueOfInt32(value)
	case "ics23.InnerSpec.min_prefix_length":
		value := x.MinPrefixLength
		return protoreflect.ValueOfInt32(value)
	case "ics23.InnerSpec.max_prefix_length":
		value := x.MaxPrefixLength
		return protoreflect.ValueOfInt32(value)
	case "ics23.InnerSpec.empty_child":
		value := x.EmptyChild
		return protoreflect.ValueOfBytes(value)
	case "ics23.InnerSpec.hash":
		value := x.Hash
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.InnerSpec"))
		}
		panic(fmt.Errorf("message ics23.InnerSpec does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_InnerSpec) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ics23.InnerSpec.child_order":
		lv := value.List()
		clv := lv.(*_InnerSpec_1_list)
		x.ChildOrder = *clv.list
	case "ics23.InnerSpec.child_size":
		x.ChildSize = int32(value.Int())
	case "ics23.InnerSpec.min_prefix_length":
		x.MinPrefixLength = int32(value.Int())
	case "ics23.InnerSpec.max_prefix_length":
		x.MaxPrefixLength = int32(value.Int())
	case "ics23.InnerSpec.empty_child":
		x.EmptyChild = value.Bytes()
	case "ics23.InnerSpec.hash":
		x.Hash = (HashOp)(value.Enum())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.InnerSpec"))
		}
		panic(fmt.Errorf("message ics23.InnerSpec does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_InnerSpec) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.InnerSpec.child_order":
		if x.ChildOrder == nil {
			x.ChildOrder = []int32{}
		}
		value := &_InnerSpec_1_list{list: &x.ChildOrder}
		return protoreflect.ValueOfList(value)
	case "ics23.InnerSpec.child_size":
		panic(fmt.Errorf("field child_size of message ics23.InnerSpec is not mutable"))
	case "ics23.InnerSpec.min_prefix_length":
		panic(fmt.Errorf("field min_prefix_length of message ics23.InnerSpec is not mutable"))
	case "ics23.InnerSpec.max_prefix_length":
		panic(fmt.Errorf("field max_prefix_length of message ics23.InnerSpec is not mutable"))
	case "ics23.InnerSpec.empty_child":
		panic(fmt.Errorf("field empty_child of message ics23.InnerSpec is not mutable"))
	case "ics23.InnerSpec.hash":
		panic(fmt.Errorf("field hash of message ics23.InnerSpec is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.InnerSpec"))
		}
		panic(fmt.Errorf("message ics23.InnerSpec does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_InnerSpec) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.InnerSpec.child_order":
		list := []int32{}
		return protoreflect.ValueOfList(&_InnerSpec_1_list{list: &list})
	case "ics23.InnerSpec.child_size":
		return protoreflect.ValueOfInt32(int32(0))
	case "ics23.InnerSpec.min_prefix_length":
		return protoreflect.ValueOfInt32(int32(0))
	case "ics23.InnerSpec.max_prefix_length":
		return protoreflect.ValueOfInt32(int32(0))
	case "ics23.InnerSpec.empty_child":
		return protoreflect.ValueOfBytes(nil)
	case "ics23.InnerSpec.hash":
		return protoreflect.ValueOfEnum(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.InnerSpec"))
		}
		panic(fmt.Errorf("message ics23.InnerSpec does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_InnerSpec) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ics23.InnerSpec", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_InnerSpec) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_InnerSpec) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_InnerSpec) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_InnerSpec) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*InnerSpec)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.ChildOrder) > 0 {
			l = 0
			for _, e := range x.ChildOrder {
				l += runtime.Sov(uint64(e))
			}
			n += 1 + runtime.Sov(uint64(l)) + l
		}
		if x.ChildSize != 0 {
			n += 1 + runtime.Sov(uint64(x.ChildSize))
		}
		if x.MinPrefixLength != 0 {
			n += 1 + runtime.Sov(uint64(x.MinPrefixLength))
		}
		if x.MaxPrefixLength != 0 {
			n += 1 + runtime.Sov(uint64(x.MaxPrefixLength))
		}
		l = len(x.EmptyChild)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Hash != 0 {
			n += 1 + runtime.Sov(uint64(x.Hash))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*InnerSpec)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Hash != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Hash))
			i--
			dAtA[i] = 0x30
		}
		if len(x.EmptyChild) > 0 {
			i -= len(x.EmptyChild)
			copy(dAtA[i:], x.EmptyChild)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.EmptyChild)))
			i--
			dAtA[i] = 0x2a
		}
		if x.MaxPrefixLength != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MaxPrefixLength))
			i--
			dAtA[i] = 0x20
		}
		if x.MinPrefixLength != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MinPrefixLength))
			i--
			dAtA[i] = 0x18
		}
		if x.ChildSize != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.ChildSize))
			i--
			dAtA[i] = 0x10
		}
		if len(x.ChildOrder) > 0 {
			var pksize2 int
			for _, num := range x.ChildOrder {
				pksize2 += runtime.Sov(uint64(num))
			}
			i -= pksize2
			j1 := i
			for _, num1 := range x.ChildOrder {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j1++
				}
				dAtA[j1] = uint8(num)
				j1++
			}
			i = runtime.EncodeVarint(dAtA, i, uint64(pksize2))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*InnerSpec)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: InnerSpec: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: InnerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType == 0 {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					x.ChildOrder = append(x.ChildOrder, v)
				} else if wireType == 2 {
					var packedLen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						packedLen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if packedLen < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					postIndex := iNdEx + packedLen
					if postIndex < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					if postIndex > l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					var elementCount int
					var count int
					for _, integer := range dAtA[iNdEx:postIndex] {
						if integer < 128 {
							count++
						}
					}
					elementCount = count
					if elementCount != 0 && len(x.ChildOrder) == 0 {
						x.ChildOrder = make([]int32, 0, elementCount)
					}
					for iNdEx < postIndex {
						var v int32
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							v |= int32(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						x.ChildOrder = append(x.ChildOrder, v)
					}
				} else {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ChildOrder", wireType)
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ChildSize", wireType)
				}
				x.ChildSize = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.ChildSize |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MinPrefixLength", wireType)
				}
				x.MinPrefixLength = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MinPrefixLength |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxPrefixLength", wireType)
				}
				x.MaxPrefixLength = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MaxPrefixLength |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EmptyChild", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.EmptyChild = append(x.EmptyChild[:0], dAtA[iNdEx:postIndex]...)
				if x.EmptyChild == nil {
					x.EmptyChild = []byte{}
				}
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
				}
				x.Hash = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Hash |= HashOp(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_BatchProof_1_list)(nil)

type _BatchProof_1_list struct {
	list *[]*BatchEntry
}

func (x *_BatchProof_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_BatchProof_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_BatchProof_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*BatchEntry)
	(*x.list)[i] = concreteValue
}

func (x *_BatchProof_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*BatchEntry)
	*x.list = append(*x.list, concreteValue)
}

func (x *_BatchProof_1_list) AppendMutable() protoreflect.Value {
	v := new(BatchEntry)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_BatchProof_1_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_BatchProof_1_list) NewElement() protoreflect.Value {
	v := new(BatchEntry)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_BatchProof_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_BatchProof         protoreflect.MessageDescriptor
	fd_BatchProof_entries protoreflect.FieldDescriptor
)

func init() {
	file_proofs_proto_init()
	md_BatchProof = File_proofs_proto.Messages().ByName("BatchProof")
	fd_BatchProof_entries = md_BatchProof.Fields().ByName("entries")
}

var _ protoreflect.Message = (*fastReflection_BatchProof)(nil)

type fastReflection_BatchProof BatchProof

func (x *BatchProof) ProtoReflect() protoreflect.Message {
	return (*fastReflection_BatchProof)(x)
}

func (x *BatchProof) slowProtoReflect() protoreflect.Message {
	mi := &file_proofs_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_BatchProof_messageType fastReflection_BatchProof_messageType
var _ protoreflect.MessageType = fastReflection_BatchProof_messageType{}

type fastReflection_BatchProof_messageType struct{}

func (x fastReflection_BatchProof_messageType) Zero() protoreflect.Message {
	return (*fastReflection_BatchProof)(nil)
}
func (x fastReflection_BatchProof_messageType) New() protoreflect.Message {
	return new(fastReflection_BatchProof)
}
func (x fastReflection_BatchProof_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_BatchProof
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_BatchProof) Descriptor() protoreflect.MessageDescriptor {
	return md_BatchProof
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_BatchProof) Type() protoreflect.MessageType {
	return _fastReflection_BatchProof_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_BatchProof) New() protoreflect.Message {
	return new(fastReflection_BatchProof)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_BatchProof) Interface() protoreflect.ProtoMessage {
	return (*BatchProof)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_BatchProof) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Entries) != 0 {
		value := protoreflect.ValueOfList(&_BatchProof_1_list{list: &x.Entries})
		if !f(fd_BatchProof_entries, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_BatchProof) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ics23.BatchProof.entries":
		return len(x.Entries) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.BatchProof"))
		}
		panic(fmt.Errorf("message ics23.BatchProof does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BatchProof) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ics23.BatchProof.entries":
		x.Entries = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.BatchProof"))
		}
		panic(fmt.Errorf("message ics23.BatchProof does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_BatchProof) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ics23.BatchProof.entries":
		if len(x.Entries) == 0 {
			return protoreflect.ValueOfList(&_BatchProof_1_list{})
		}
		listValue := &_BatchProof_1_list{list: &x.Entries}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.BatchProof"))
		}
		panic(fmt.Errorf("message ics23.BatchProof does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BatchProof) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ics23.BatchProof.entries":
		lv := value.List()
		clv := lv.(*_BatchProof_1_list)
		x.Entries = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.BatchProof"))
		}
		panic(fmt.Errorf("message ics23.BatchProof does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BatchProof) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.BatchProof.entries":
		if x.Entries == nil {
			x.Entries = []*BatchEntry{}
		}
		value := &_BatchProof_1_list{list: &x.Entries}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.BatchProof"))
		}
		panic(fmt.Errorf("message ics23.BatchProof does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_BatchProof) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.BatchProof.entries":
		list := []*BatchEntry{}
		return protoreflect.ValueOfList(&_BatchProof_1_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.BatchProof"))
		}
		panic(fmt.Errorf("message ics23.BatchProof does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_BatchProof) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ics23.BatchProof", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_BatchProof) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BatchProof) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_BatchProof) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_BatchProof) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*BatchProof)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.Entries) > 0 {
			for _, e := range x.Entries {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*BatchProof)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Entries) > 0 {
			for iNdEx := len(x.Entries) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Entries[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*BatchProof)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: BatchProof: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: BatchProof: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Entries = append(x.Entries, &BatchEntry{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Entries[len(x.Entries)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_BatchEntry          protoreflect.MessageDescriptor
	fd_BatchEntry_exist    protoreflect.FieldDescriptor
	fd_BatchEntry_nonexist protoreflect.FieldDescriptor
)

func init() {
	file_proofs_proto_init()
	md_BatchEntry = File_proofs_proto.Messages().ByName("BatchEntry")
	fd_BatchEntry_exist = md_BatchEntry.Fields().ByName("exist")
	fd_BatchEntry_nonexist = md_BatchEntry.Fields().ByName("nonexist")
}

var _ protoreflect.Message = (*fastReflection_BatchEntry)(nil)

type fastReflection_BatchEntry BatchEntry

func (x *BatchEntry) ProtoReflect() protoreflect.Message {
	return (*fastReflection_BatchEntry)(x)
}

func (x *BatchEntry) slowProtoReflect() protoreflect.Message {
	mi := &file_proofs_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_BatchEntry_messageType fastReflection_BatchEntry_messageType
var _ protoreflect.MessageType = fastReflection_BatchEntry_messageType{}

type fastReflection_BatchEntry_messageType struct{}

func (x fastReflection_BatchEntry_messageType) Zero() protoreflect.Message {
	return (*fastReflection_BatchEntry)(nil)
}
func (x fastReflection_BatchEntry_messageType) New() protoreflect.Message {
	return new(fastReflection_BatchEntry)
}
func (x fastReflection_BatchEntry_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_BatchEntry
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_BatchEntry) Descriptor() protoreflect.MessageDescriptor {
	return md_BatchEntry
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_BatchEntry) Type() protoreflect.MessageType {
	return _fastReflection_BatchEntry_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_BatchEntry) New() protoreflect.Message {
	return new(fastReflection_BatchEntry)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_BatchEntry) Interface() protoreflect.ProtoMessage {
	return (*BatchEntry)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_BatchEntry) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Proof != nil {
		switch o := x.Proof.(type) {
		case *BatchEntry_Exist:
			v := o.Exist
			value := protoreflect.ValueOfMessage(v.ProtoReflect())
			if !f(fd_BatchEntry_exist, value) {
				return
			}
		case *BatchEntry_Nonexist:
			v := o.Nonexist
			value := protoreflect.ValueOfMessage(v.ProtoReflect())
			if !f(fd_BatchEntry_nonexist, value) {
				return
			}
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_BatchEntry) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ics23.BatchEntry.exist":
		if x.Proof == nil {
			return false
		} else if _, ok := x.Proof.(*BatchEntry_Exist); ok {
			return true
		} else {
			return false
		}
	case "ics23.BatchEntry.nonexist":
		if x.Proof == nil {
			return false
		} else if _, ok := x.Proof.(*BatchEntry_Nonexist); ok {
			return true
		} else {
			return false
		}
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.BatchEntry"))
		}
		panic(fmt.Errorf("message ics23.BatchEntry does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BatchEntry) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ics23.BatchEntry.exist":
		x.Proof = nil
	case "ics23.BatchEntry.nonexist":
		x.Proof = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.BatchEntry"))
		}
		panic(fmt.Errorf("message ics23.BatchEntry does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_BatchEntry) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ics23.BatchEntry.exist":
		if x.Proof == nil {
			return protoreflect.ValueOfMessage((*ExistenceProof)(nil).ProtoReflect())
		} else if v, ok := x.Proof.(*BatchEntry_Exist); ok {
			return protoreflect.ValueOfMessage(v.Exist.ProtoReflect())
		} else {
			return protoreflect.ValueOfMessage((*ExistenceProof)(nil).ProtoReflect())
		}
	case "ics23.BatchEntry.nonexist":
		if x.Proof == nil {
			return protoreflect.ValueOfMessage((*NonExistenceProof)(nil).ProtoReflect())
		} else if v, ok := x.Proof.(*BatchEntry_Nonexist); ok {
			return protoreflect.ValueOfMessage(v.Nonexist.ProtoReflect())
		} else {
			return protoreflect.ValueOfMessage((*NonExistenceProof)(nil).ProtoReflect())
		}
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.BatchEntry"))
		}
		panic(fmt.Errorf("message ics23.BatchEntry does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BatchEntry) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ics23.BatchEntry.exist":
		cv := value.Message().Interface().(*ExistenceProof)
		x.Proof = &BatchEntry_Exist{Exist: cv}
	case "ics23.BatchEntry.nonexist":
		cv := value.Message().Interface().(*NonExistenceProof)
		x.Proof = &BatchEntry_Nonexist{Nonexist: cv}
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.BatchEntry"))
		}
		panic(fmt.Errorf("message ics23.BatchEntry does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BatchEntry) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.BatchEntry.exist":
		if x.Proof == nil {
			value := &ExistenceProof{}
			oneofValue := &BatchEntry_Exist{Exist: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
		switch m := x.Proof.(type) {
		case *BatchEntry_Exist:
			return protoreflect.ValueOfMessage(m.Exist.ProtoReflect())
		default:
			value := &ExistenceProof{}
			oneofValue := &BatchEntry_Exist{Exist: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
	case "ics23.BatchEntry.nonexist":
		if x.Proof == nil {
			value := &NonExistenceProof{}
			oneofValue := &BatchEntry_Nonexist{Nonexist: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
		switch m := x.Proof.(type) {
		case *BatchEntry_Nonexist:
			return protoreflect.ValueOfMessage(m.Nonexist.ProtoReflect())
		default:
			value := &NonExistenceProof{}
			oneofValue := &BatchEntry_Nonexist{Nonexist: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.BatchEntry"))
		}
		panic(fmt.Errorf("message ics23.BatchEntry does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_BatchEntry) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.BatchEntry.exist":
		value := &ExistenceProof{}
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "ics23.BatchEntry.nonexist":
		value := &NonExistenceProof{}
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.BatchEntry"))
		}
		panic(fmt.Errorf("message ics23.BatchEntry does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_BatchEntry) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	case "ics23.BatchEntry.proof":
		if x.Proof == nil {
			return nil
		}
		switch x.Proof.(type) {
		case *BatchEntry_Exist:
			return x.Descriptor().Fields().ByName("exist")
		case *BatchEntry_Nonexist:
			return x.Descriptor().Fields().ByName("nonexist")
		}
	default:
		panic(fmt.Errorf("%s is not a oneof field in ics23.BatchEntry", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_BatchEntry) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BatchEntry) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_BatchEntry) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_BatchEntry) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*BatchEntry)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		switch x := x.Proof.(type) {
		case *BatchEntry_Exist:
			if x == nil {
				break
			}
			l = options.Size(x.Exist)
			n += 1 + l + runtime.Sov(uint64(l))
		case *BatchEntry_Nonexist:
			if x == nil {
				break
			}
			l = options.Size(x.Nonexist)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*BatchEntry)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		switch x := x.Proof.(type) {
		case *BatchEntry_Exist:
			encoded, err := options.Marshal(x.Exist)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		case *BatchEntry_Nonexist:
			encoded, err := options.Marshal(x.Nonexist)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*BatchEntry)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: BatchEntry: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: BatchEntry: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Exist", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				v := &ExistenceProof{}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], v); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				x.Proof = &BatchEntry_Exist{v}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonexist", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				v := &NonExistenceProof{}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], v); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				x.Proof = &BatchEntry_Nonexist{v}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_CompressedBatchProof_1_list)(nil)

type _CompressedBatchProof_1_list struct {
	list *[]*CompressedBatchEntry
}

func (x *_CompressedBatchProof_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_CompressedBatchProof_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_CompressedBatchProof_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*CompressedBatchEntry)
	(*x.list)[i] = concreteValue
}

func (x *_CompressedBatchProof_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*CompressedBatchEntry)
	*x.list = append(*x.list, concreteValue)
}

func (x *_CompressedBatchProof_1_list) AppendMutable() protoreflect.Value {
	v := new(CompressedBatchEntry)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_CompressedBatchProof_1_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_CompressedBatchProof_1_list) NewElement() protoreflect.Value {
	v := new(CompressedBatchEntry)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_CompressedBatchProof_1_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_CompressedBatchProof_2_list)(nil)

type _CompressedBatchProof_2_list struct {
	list *[]*InnerOp
}

func (x *_CompressedBatchProof_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_CompressedBatchProof_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_CompressedBatchProof_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*InnerOp)
	(*x.list)[i] = concreteValue
}

func (x *_CompressedBatchProof_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*InnerOp)
	*x.list = append(*x.list, concreteValue)
}

func (x *_CompressedBatchProof_2_list) AppendMutable() protoreflect.Value {
	v := new(InnerOp)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_CompressedBatchProof_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_CompressedBatchProof_2_list) NewElement() protoreflect.Value {
	v := new(InnerOp)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_CompressedBatchProof_2_list) IsValid() bool {
	return x.list != nil
}

var (
	md_CompressedBatchProof               protoreflect.MessageDescriptor
	fd_CompressedBatchProof_entries       protoreflect.FieldDescriptor
	fd_CompressedBatchProof_lookup_inners protoreflect.FieldDescriptor
)

func init() {
	file_proofs_proto_init()
	md_CompressedBatchProof = File_proofs_proto.Messages().ByName("CompressedBatchProof")
	fd_CompressedBatchProof_entries = md_CompressedBatchProof.Fields().ByName("entries")
	fd_CompressedBatchProof_lookup_inners = md_CompressedBatchProof.Fields().ByName("lookup_inners")
}

var _ protoreflect.Message = (*fastReflection_CompressedBatchProof)(nil)

type fastReflection_CompressedBatchProof CompressedBatchProof

func (x *CompressedBatchProof) ProtoReflect() protoreflect.Message {
	return (*fastReflection_CompressedBatchProof)(x)
}

func (x *CompressedBatchProof) slowProtoReflect() protoreflect.Message {
	mi := &file_proofs_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_CompressedBatchProof_messageType fastReflection_CompressedBatchProof_messageType
var _ protoreflect.MessageType = fastReflection_CompressedBatchProof_messageType{}

type fastReflection_CompressedBatchProof_messageType struct{}

func (x fastReflection_CompressedBatchProof_messageType) Zero() protoreflect.Message {
	return (*fastReflection_CompressedBatchProof)(nil)
}
func (x fastReflection_CompressedBatchProof_messageType) New() protoreflect.Message {
	return new(fastReflection_CompressedBatchProof)
}
func (x fastReflection_CompressedBatchProof_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_CompressedBatchProof
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_CompressedBatchProof) Descriptor() protoreflect.MessageDescriptor {
	return md_CompressedBatchProof
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_CompressedBatchProof) Type() protoreflect.MessageType {
	return _fastReflection_CompressedBatchProof_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_CompressedBatchProof) New() protoreflect.Message {
	return new(fastReflection_CompressedBatchProof)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_CompressedBatchProof) Interface() protoreflect.ProtoMessage {
	return (*CompressedBatchProof)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_CompressedBatchProof) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Entries) != 0 {
		value := protoreflect.ValueOfList(&_CompressedBatchProof_1_list{list: &x.Entries})
		if !f(fd_CompressedBatchProof_entries, value) {
			return
		}
	}
	if len(x.LookupInners) != 0 {
		value := protoreflect.ValueOfList(&_CompressedBatchProof_2_list{list: &x.LookupInners})
		if !f(fd_CompressedBatchProof_lookup_inners, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_CompressedBatchProof) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ics23.CompressedBatchProof.entries":
		return len(x.Entries) != 0
	case "ics23.CompressedBatchProof.lookup_inners":
		return len(x.LookupInners) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedBatchProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedBatchProof does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedBatchProof) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ics23.CompressedBatchProof.entries":
		x.Entries = nil
	case "ics23.CompressedBatchProof.lookup_inners":
		x.LookupInners = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedBatchProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedBatchProof does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_CompressedBatchProof) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ics23.CompressedBatchProof.entries":
		if len(x.Entries) == 0 {
			return protoreflect.ValueOfList(&_CompressedBatchProof_1_list{})
		}
		listValue := &_CompressedBatchProof_1_list{list: &x.Entries}
		return protoreflect.ValueOfList(listValue)
	case "ics23.CompressedBatchProof.lookup_inners":
		if len(x.LookupInners) == 0 {
			return protoreflect.ValueOfList(&_CompressedBatchProof_2_list{})
		}
		listValue := &_CompressedBatchProof_2_list{list: &x.LookupInners}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedBatchProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedBatchProof does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedBatchProof) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ics23.CompressedBatchProof.entries":
		lv := value.List()
		clv := lv.(*_CompressedBatchProof_1_list)
		x.Entries = *clv.list
	case "ics23.CompressedBatchProof.lookup_inners":
		lv := value.List()
		clv := lv.(*_CompressedBatchProof_2_list)
		x.LookupInners = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedBatchProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedBatchProof does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedBatchProof) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.CompressedBatchProof.entries":
		if x.Entries == nil {
			x.Entries = []*CompressedBatchEntry{}
		}
		value := &_CompressedBatchProof_1_list{list: &x.Entries}
		return protoreflect.ValueOfList(value)
	case "ics23.CompressedBatchProof.lookup_inners":
		if x.LookupInners == nil {
			x.LookupInners = []*InnerOp{}
		}
		value := &_CompressedBatchProof_2_list{list: &x.LookupInners}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedBatchProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedBatchProof does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_CompressedBatchProof) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.CompressedBatchProof.entries":
		list := []*CompressedBatchEntry{}
		return protoreflect.ValueOfList(&_CompressedBatchProof_1_list{list: &list})
	case "ics23.CompressedBatchProof.lookup_inners":
		list := []*InnerOp{}
		return protoreflect.ValueOfList(&_CompressedBatchProof_2_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedBatchProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedBatchProof does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_CompressedBatchProof) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ics23.CompressedBatchProof", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_CompressedBatchProof) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedBatchProof) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_CompressedBatchProof) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_CompressedBatchProof) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*CompressedBatchProof)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.Entries) > 0 {
			for _, e := range x.Entries {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.LookupInners) > 0 {
			for _, e := range x.LookupInners {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*CompressedBatchProof)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.LookupInners) > 0 {
			for iNdEx := len(x.LookupInners) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.LookupInners[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.Entries) > 0 {
			for iNdEx := len(x.Entries) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Entries[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*CompressedBatchProof)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CompressedBatchProof: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CompressedBatchProof: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Entries = append(x.Entries, &CompressedBatchEntry{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Entries[len(x.Entries)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LookupInners", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LookupInners = append(x.LookupInners, &InnerOp{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.LookupInners[len(x.LookupInners)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_CompressedBatchEntry          protoreflect.MessageDescriptor
	fd_CompressedBatchEntry_exist    protoreflect.FieldDescriptor
	fd_CompressedBatchEntry_nonexist protoreflect.FieldDescriptor
)

func init() {
	file_proofs_proto_init()
	md_CompressedBatchEntry = File_proofs_proto.Messages().ByName("CompressedBatchEntry")
	fd_CompressedBatchEntry_exist = md_CompressedBatchEntry.Fields().ByName("exist")
	fd_CompressedBatchEntry_nonexist = md_CompressedBatchEntry.Fields().ByName("nonexist")
}

var _ protoreflect.Message = (*fastReflection_CompressedBatchEntry)(nil)

type fastReflection_CompressedBatchEntry CompressedBatchEntry

func (x *CompressedBatchEntry) ProtoReflect() protoreflect.Message {
	return (*fastReflection_CompressedBatchEntry)(x)
}

func (x *CompressedBatchEntry) slowProtoReflect() protoreflect.Message {
	mi := &file_proofs_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_CompressedBatchEntry_messageType fastReflection_CompressedBatchEntry_messageType
var _ protoreflect.MessageType = fastReflection_CompressedBatchEntry_messageType{}

type fastReflection_CompressedBatchEntry_messageType struct{}

func (x fastReflection_CompressedBatchEntry_messageType) Zero() protoreflect.Message {
	return (*fastReflection_CompressedBatchEntry)(nil)
}
func (x fastReflection_CompressedBatchEntry_messageType) New() protoreflect.Message {
	return new(fastReflection_CompressedBatchEntry)
}
func (x fastReflection_CompressedBatchEntry_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_CompressedBatchEntry
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_CompressedBatchEntry) Descriptor() protoreflect.MessageDescriptor {
	return md_CompressedBatchEntry
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_CompressedBatchEntry) Type() protoreflect.MessageType {
	return _fastReflection_CompressedBatchEntry_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_CompressedBatchEntry) New() protoreflect.Message {
	return new(fastReflection_CompressedBatchEntry)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_CompressedBatchEntry) Interface() protoreflect.ProtoMessage {
	return (*CompressedBatchEntry)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_CompressedBatchEntry) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Proof != nil {
		switch o := x.Proof.(type) {
		case *CompressedBatchEntry_Exist:
			v := o.Exist
			value := protoreflect.ValueOfMessage(v.ProtoReflect())
			if !f(fd_CompressedBatchEntry_exist, value) {
				return
			}
		case *CompressedBatchEntry_Nonexist:
			v := o.Nonexist
			value := protoreflect.ValueOfMessage(v.ProtoReflect())
			if !f(fd_CompressedBatchEntry_nonexist, value) {
				return
			}
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_CompressedBatchEntry) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ics23.CompressedBatchEntry.exist":
		if x.Proof == nil {
			return false
		} else if _, ok := x.Proof.(*CompressedBatchEntry_Exist); ok {
			return true
		} else {
			return false
		}
	case "ics23.CompressedBatchEntry.nonexist":
		if x.Proof == nil {
			return false
		} else if _, ok := x.Proof.(*CompressedBatchEntry_Nonexist); ok {
			return true
		} else {
			return false
		}
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedBatchEntry"))
		}
		panic(fmt.Errorf("message ics23.CompressedBatchEntry does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedBatchEntry) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ics23.CompressedBatchEntry.exist":
		x.Proof = nil
	case "ics23.CompressedBatchEntry.nonexist":
		x.Proof = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedBatchEntry"))
		}
		panic(fmt.Errorf("message ics23.CompressedBatchEntry does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_CompressedBatchEntry) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ics23.CompressedBatchEntry.exist":
		if x.Proof == nil {
			return protoreflect.ValueOfMessage((*CompressedExistenceProof)(nil).ProtoReflect())
		} else if v, ok := x.Proof.(*CompressedBatchEntry_Exist); ok {
			return protoreflect.ValueOfMessage(v.Exist.ProtoReflect())
		} else {
			return protoreflect.ValueOfMessage((*CompressedExistenceProof)(nil).ProtoReflect())
		}
	case "ics23.CompressedBatchEntry.nonexist":
		if x.Proof == nil {
			return protoreflect.ValueOfMessage((*CompressedNonExistenceProof)(nil).ProtoReflect())
		} else if v, ok := x.Proof.(*CompressedBatchEntry_Nonexist); ok {
			return protoreflect.ValueOfMessage(v.Nonexist.ProtoReflect())
		} else {
			return protoreflect.ValueOfMessage((*CompressedNonExistenceProof)(nil).ProtoReflect())
		}
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedBatchEntry"))
		}
		panic(fmt.Errorf("message ics23.CompressedBatchEntry does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedBatchEntry) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ics23.CompressedBatchEntry.exist":
		cv := value.Message().Interface().(*CompressedExistenceProof)
		x.Proof = &CompressedBatchEntry_Exist{Exist: cv}
	case "ics23.CompressedBatchEntry.nonexist":
		cv := value.Message().Interface().(*CompressedNonExistenceProof)
		x.Proof = &CompressedBatchEntry_Nonexist{Nonexist: cv}
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedBatchEntry"))
		}
		panic(fmt.Errorf("message ics23.CompressedBatchEntry does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedBatchEntry) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.CompressedBatchEntry.exist":
		if x.Proof == nil {
			value := &CompressedExistenceProof{}
			oneofValue := &CompressedBatchEntry_Exist{Exist: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
		switch m := x.Proof.(type) {
		case *CompressedBatchEntry_Exist:
			return protoreflect.ValueOfMessage(m.Exist.ProtoReflect())
		default:
			value := &CompressedExistenceProof{}
			oneofValue := &CompressedBatchEntry_Exist{Exist: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
	case "ics23.CompressedBatchEntry.nonexist":
		if x.Proof == nil {
			value := &CompressedNonExistenceProof{}
			oneofValue := &CompressedBatchEntry_Nonexist{Nonexist: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
		switch m := x.Proof.(type) {
		case *CompressedBatchEntry_Nonexist:
			return protoreflect.ValueOfMessage(m.Nonexist.ProtoReflect())
		default:
			value := &CompressedNonExistenceProof{}
			oneofValue := &CompressedBatchEntry_Nonexist{Nonexist: value}
			x.Proof = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedBatchEntry"))
		}
		panic(fmt.Errorf("message ics23.CompressedBatchEntry does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_CompressedBatchEntry) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.CompressedBatchEntry.exist":
		value := &CompressedExistenceProof{}
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "ics23.CompressedBatchEntry.nonexist":
		value := &CompressedNonExistenceProof{}
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedBatchEntry"))
		}
		panic(fmt.Errorf("message ics23.CompressedBatchEntry does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_CompressedBatchEntry) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	case "ics23.CompressedBatchEntry.proof":
		if x.Proof == nil {
			return nil
		}
		switch x.Proof.(type) {
		case *CompressedBatchEntry_Exist:
			return x.Descriptor().Fields().ByName("exist")
		case *CompressedBatchEntry_Nonexist:
			return x.Descriptor().Fields().ByName("nonexist")
		}
	default:
		panic(fmt.Errorf("%s is not a oneof field in ics23.CompressedBatchEntry", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_CompressedBatchEntry) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedBatchEntry) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_CompressedBatchEntry) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_CompressedBatchEntry) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*CompressedBatchEntry)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		switch x := x.Proof.(type) {
		case *CompressedBatchEntry_Exist:
			if x == nil {
				break
			}
			l = options.Size(x.Exist)
			n += 1 + l + runtime.Sov(uint64(l))
		case *CompressedBatchEntry_Nonexist:
			if x == nil {
				break
			}
			l = options.Size(x.Nonexist)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*CompressedBatchEntry)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		switch x := x.Proof.(type) {
		case *CompressedBatchEntry_Exist:
			encoded, err := options.Marshal(x.Exist)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		case *CompressedBatchEntry_Nonexist:
			encoded, err := options.Marshal(x.Nonexist)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*CompressedBatchEntry)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CompressedBatchEntry: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CompressedBatchEntry: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Exist", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				v := &CompressedExistenceProof{}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], v); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				x.Proof = &CompressedBatchEntry_Exist{v}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonexist", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				v := &CompressedNonExistenceProof{}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], v); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				x.Proof = &CompressedBatchEntry_Nonexist{v}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_CompressedExistenceProof_4_list)(nil)

type _CompressedExistenceProof_4_list struct {
	list *[]int32
}

func (x *_CompressedExistenceProof_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_CompressedExistenceProof_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfInt32((*x.list)[i])
}

func (x *_CompressedExistenceProof_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Int()
	concreteValue := (int32)(valueUnwrapped)
	(*x.list)[i] = concreteValue
}

func (x *_CompressedExistenceProof_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Int()
	concreteValue := (int32)(valueUnwrapped)
	*x.list = append(*x.list, concreteValue)
}

func (x *_CompressedExistenceProof_4_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message CompressedExistenceProof at list field Path as it is not of Message kind"))
}

func (x *_CompressedExistenceProof_4_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_CompressedExistenceProof_4_list) NewElement() protoreflect.Value {
	v := int32(0)
	return protoreflect.ValueOfInt32(v)
}

func (x *_CompressedExistenceProof_4_list) IsValid() bool {
	return x.list != nil
}

var (
	md_CompressedExistenceProof       protoreflect.MessageDescriptor
	fd_CompressedExistenceProof_key   protoreflect.FieldDescriptor
	fd_CompressedExistenceProof_value protoreflect.FieldDescriptor
	fd_CompressedExistenceProof_leaf  protoreflect.FieldDescriptor
	fd_CompressedExistenceProof_path  protoreflect.FieldDescriptor
)

func init() {
	file_proofs_proto_init()
	md_CompressedExistenceProof = File_proofs_proto.Messages().ByName("CompressedExistenceProof")
	fd_CompressedExistenceProof_key = md_CompressedExistenceProof.Fields().ByName("key")
	fd_CompressedExistenceProof_value = md_CompressedExistenceProof.Fields().ByName("value")
	fd_CompressedExistenceProof_leaf = md_CompressedExistenceProof.Fields().ByName("leaf")
	fd_CompressedExistenceProof_path = md_CompressedExistenceProof.Fields().ByName("path")
}

var _ protoreflect.Message = (*fastReflection_CompressedExistenceProof)(nil)

type fastReflection_CompressedExistenceProof CompressedExistenceProof

func (x *CompressedExistenceProof) ProtoReflect() protoreflect.Message {
	return (*fastReflection_CompressedExistenceProof)(x)
}

func (x *CompressedExistenceProof) slowProtoReflect() protoreflect.Message {
	mi := &file_proofs_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_CompressedExistenceProof_messageType fastReflection_CompressedExistenceProof_messageType
var _ protoreflect.MessageType = fastReflection_CompressedExistenceProof_messageType{}

type fastReflection_CompressedExistenceProof_messageType struct{}

func (x fastReflection_CompressedExistenceProof_messageType) Zero() protoreflect.Message {
	return (*fastReflection_CompressedExistenceProof)(nil)
}
func (x fastReflection_CompressedExistenceProof_messageType) New() protoreflect.Message {
	return new(fastReflection_CompressedExistenceProof)
}
func (x fastReflection_CompressedExistenceProof_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_CompressedExistenceProof
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_CompressedExistenceProof) Descriptor() protoreflect.MessageDescriptor {
	return md_CompressedExistenceProof
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_CompressedExistenceProof) Type() protoreflect.MessageType {
	return _fastReflection_CompressedExistenceProof_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_CompressedExistenceProof) New() protoreflect.Message {
	return new(fastReflection_CompressedExistenceProof)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_CompressedExistenceProof) Interface() protoreflect.ProtoMessage {
	return (*CompressedExistenceProof)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_CompressedExistenceProof) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Key) != 0 {
		value := protoreflect.ValueOfBytes(x.Key)
		if !f(fd_CompressedExistenceProof_key, value) {
			return
		}
	}
	if len(x.Value) != 0 {
		value := protoreflect.ValueOfBytes(x.Value)
		if !f(fd_CompressedExistenceProof_value, value) {
			return
		}
	}
	if x.Leaf != nil {
		value := protoreflect.ValueOfMessage(x.Leaf.ProtoReflect())
		if !f(fd_CompressedExistenceProof_leaf, value) {
			return
		}
	}
	if len(x.Path) != 0 {
		value := protoreflect.ValueOfList(&_CompressedExistenceProof_4_list{list: &x.Path})
		if !f(fd_CompressedExistenceProof_path, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_CompressedExistenceProof) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ics23.CompressedExistenceProof.key":
		return len(x.Key) != 0
	case "ics23.CompressedExistenceProof.value":
		return len(x.Value) != 0
	case "ics23.CompressedExistenceProof.leaf":
		return x.Leaf != nil
	case "ics23.CompressedExistenceProof.path":
		return len(x.Path) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedExistenceProof does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedExistenceProof) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ics23.CompressedExistenceProof.key":
		x.Key = nil
	case "ics23.CompressedExistenceProof.value":
		x.Value = nil
	case "ics23.CompressedExistenceProof.leaf":
		x.Leaf = nil
	case "ics23.CompressedExistenceProof.path":
		x.Path = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedExistenceProof does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_CompressedExistenceProof) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ics23.CompressedExistenceProof.key":
		value := x.Key
		return protoreflect.ValueOfBytes(value)
	case "ics23.CompressedExistenceProof.value":
		value := x.Value
		return protoreflect.ValueOfBytes(value)
	case "ics23.CompressedExistenceProof.leaf":
		value := x.Leaf
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "ics23.CompressedExistenceProof.path":
		if len(x.Path) == 0 {
			return protoreflect.ValueOfList(&_CompressedExistenceProof_4_list{})
		}
		listValue := &_CompressedExistenceProof_4_list{list: &x.Path}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedExistenceProof does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedExistenceProof) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ics23.CompressedExistenceProof.key":
		x.Key = value.Bytes()
	case "ics23.CompressedExistenceProof.value":
		x.Value = value.Bytes()
	case "ics23.CompressedExistenceProof.leaf":
		x.Leaf = value.Message().Interface().(*LeafOp)
	case "ics23.CompressedExistenceProof.path":
		lv := value.List()
		clv := lv.(*_CompressedExistenceProof_4_list)
		x.Path = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedExistenceProof does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedExistenceProof) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.CompressedExistenceProof.leaf":
		if x.Leaf == nil {
			x.Leaf = new(LeafOp)
		}
		return protoreflect.ValueOfMessage(x.Leaf.ProtoReflect())
	case "ics23.CompressedExistenceProof.path":
		if x.Path == nil {
			x.Path = []int32{}
		}
		value := &_CompressedExistenceProof_4_list{list: &x.Path}
		return protoreflect.ValueOfList(value)
	case "ics23.CompressedExistenceProof.key":
		panic(fmt.Errorf("field key of message ics23.CompressedExistenceProof is not mutable"))
	case "ics23.CompressedExistenceProof.value":
		panic(fmt.Errorf("field value of message ics23.CompressedExistenceProof is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedExistenceProof does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_CompressedExistenceProof) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.CompressedExistenceProof.key":
		return protoreflect.ValueOfBytes(nil)
	case "ics23.CompressedExistenceProof.value":
		return protoreflect.ValueOfBytes(nil)
	case "ics23.CompressedExistenceProof.leaf":
		m := new(LeafOp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "ics23.CompressedExistenceProof.path":
		list := []int32{}
		return protoreflect.ValueOfList(&_CompressedExistenceProof_4_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedExistenceProof does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_CompressedExistenceProof) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ics23.CompressedExistenceProof", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_CompressedExistenceProof) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedExistenceProof) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_CompressedExistenceProof) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_CompressedExistenceProof) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*CompressedExistenceProof)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Key)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Value)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Leaf != nil {
			l = options.Size(x.Leaf)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Path) > 0 {
			l = 0
			for _, e := range x.Path {
				l += runtime.Sov(uint64(e))
			}
			n += 1 + runtime.Sov(uint64(l)) + l
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*CompressedExistenceProof)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Path) > 0 {
			var pksize2 int
			for _, num := range x.Path {
				pksize2 += runtime.Sov(uint64(num))
			}
			i -= pksize2
			j1 := i
			for _, num1 := range x.Path {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j1++
				}
				dAtA[j1] = uint8(num)
				j1++
			}
			i = runtime.EncodeVarint(dAtA, i, uint64(pksize2))
			i--
			dAtA[i] = 0x22
		}
		if x.Leaf != nil {
			encoded, err := options.Marshal(x.Leaf)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Value) > 0 {
			i -= len(x.Value)
			copy(dAtA[i:], x.Value)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Value)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Key) > 0 {
			i -= len(x.Key)
			copy(dAtA[i:], x.Key)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Key)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*CompressedExistenceProof)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CompressedExistenceProof: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CompressedExistenceProof: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Key = append(x.Key[:0], dAtA[iNdEx:postIndex]...)
				if x.Key == nil {
					x.Key = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Value = append(x.Value[:0], dAtA[iNdEx:postIndex]...)
				if x.Value == nil {
					x.Value = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Leaf", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Leaf == nil {
					x.Leaf = &LeafOp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Leaf); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType == 0 {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					x.Path = append(x.Path, v)
				} else if wireType == 2 {
					var packedLen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						packedLen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if packedLen < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					postIndex := iNdEx + packedLen
					if postIndex < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					if postIndex > l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					var elementCount int
					var count int
					for _, integer := range dAtA[iNdEx:postIndex] {
						if integer < 128 {
							count++
						}
					}
					elementCount = count
					if elementCount != 0 && len(x.Path) == 0 {
						x.Path = make([]int32, 0, elementCount)
					}
					for iNdEx < postIndex {
						var v int32
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							v |= int32(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						x.Path = append(x.Path, v)
					}
				} else {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_CompressedNonExistenceProof       protoreflect.MessageDescriptor
	fd_CompressedNonExistenceProof_key   protoreflect.FieldDescriptor
	fd_CompressedNonExistenceProof_left  protoreflect.FieldDescriptor
	fd_CompressedNonExistenceProof_right protoreflect.FieldDescriptor
)

func init() {
	file_proofs_proto_init()
	md_CompressedNonExistenceProof = File_proofs_proto.Messages().ByName("CompressedNonExistenceProof")
	fd_CompressedNonExistenceProof_key = md_CompressedNonExistenceProof.Fields().ByName("key")
	fd_CompressedNonExistenceProof_left = md_CompressedNonExistenceProof.Fields().ByName("left")
	fd_CompressedNonExistenceProof_right = md_CompressedNonExistenceProof.Fields().ByName("right")
}

var _ protoreflect.Message = (*fastReflection_CompressedNonExistenceProof)(nil)

type fastReflection_CompressedNonExistenceProof CompressedNonExistenceProof

func (x *CompressedNonExistenceProof) ProtoReflect() protoreflect.Message {
	return (*fastReflection_CompressedNonExistenceProof)(x)
}

func (x *CompressedNonExistenceProof) slowProtoReflect() protoreflect.Message {
	mi := &file_proofs_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_CompressedNonExistenceProof_messageType fastReflection_CompressedNonExistenceProof_messageType
var _ protoreflect.MessageType = fastReflection_CompressedNonExistenceProof_messageType{}

type fastReflection_CompressedNonExistenceProof_messageType struct{}

func (x fastReflection_CompressedNonExistenceProof_messageType) Zero() protoreflect.Message {
	return (*fastReflection_CompressedNonExistenceProof)(nil)
}
func (x fastReflection_CompressedNonExistenceProof_messageType) New() protoreflect.Message {
	return new(fastReflection_CompressedNonExistenceProof)
}
func (x fastReflection_CompressedNonExistenceProof_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_CompressedNonExistenceProof
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_CompressedNonExistenceProof) Descriptor() protoreflect.MessageDescriptor {
	return md_CompressedNonExistenceProof
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_CompressedNonExistenceProof) Type() protoreflect.MessageType {
	return _fastReflection_CompressedNonExistenceProof_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_CompressedNonExistenceProof) New() protoreflect.Message {
	return new(fastReflection_CompressedNonExistenceProof)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_CompressedNonExistenceProof) Interface() protoreflect.ProtoMessage {
	return (*CompressedNonExistenceProof)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_CompressedNonExistenceProof) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Key) != 0 {
		value := protoreflect.ValueOfBytes(x.Key)
		if !f(fd_CompressedNonExistenceProof_key, value) {
			return
		}
	}
	if x.Left != nil {
		value := protoreflect.ValueOfMessage(x.Left.ProtoReflect())
		if !f(fd_CompressedNonExistenceProof_left, value) {
			return
		}
	}
	if x.Right != nil {
		value := protoreflect.ValueOfMessage(x.Right.ProtoReflect())
		if !f(fd_CompressedNonExistenceProof_right, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_CompressedNonExistenceProof) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ics23.CompressedNonExistenceProof.key":
		return len(x.Key) != 0
	case "ics23.CompressedNonExistenceProof.left":
		return x.Left != nil
	case "ics23.CompressedNonExistenceProof.right":
		return x.Right != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedNonExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedNonExistenceProof does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedNonExistenceProof) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ics23.CompressedNonExistenceProof.key":
		x.Key = nil
	case "ics23.CompressedNonExistenceProof.left":
		x.Left = nil
	case "ics23.CompressedNonExistenceProof.right":
		x.Right = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedNonExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedNonExistenceProof does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_CompressedNonExistenceProof) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ics23.CompressedNonExistenceProof.key":
		value := x.Key
		return protoreflect.ValueOfBytes(value)
	case "ics23.CompressedNonExistenceProof.left":
		value := x.Left
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "ics23.CompressedNonExistenceProof.right":
		value := x.Right
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedNonExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedNonExistenceProof does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedNonExistenceProof) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ics23.CompressedNonExistenceProof.key":
		x.Key = value.Bytes()
	case "ics23.CompressedNonExistenceProof.left":
		x.Left = value.Message().Interface().(*CompressedExistenceProof)
	case "ics23.CompressedNonExistenceProof.right":
		x.Right = value.Message().Interface().(*CompressedExistenceProof)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedNonExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedNonExistenceProof does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedNonExistenceProof) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.CompressedNonExistenceProof.left":
		if x.Left == nil {
			x.Left = new(CompressedExistenceProof)
		}
		return protoreflect.ValueOfMessage(x.Left.ProtoReflect())
	case "ics23.CompressedNonExistenceProof.right":
		if x.Right == nil {
			x.Right = new(CompressedExistenceProof)
		}
		return protoreflect.ValueOfMessage(x.Right.ProtoReflect())
	case "ics23.CompressedNonExistenceProof.key":
		panic(fmt.Errorf("field key of message ics23.CompressedNonExistenceProof is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedNonExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedNonExistenceProof does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_CompressedNonExistenceProof) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ics23.CompressedNonExistenceProof.key":
		return protoreflect.ValueOfBytes(nil)
	case "ics23.CompressedNonExistenceProof.left":
		m := new(CompressedExistenceProof)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "ics23.CompressedNonExistenceProof.right":
		m := new(CompressedExistenceProof)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ics23.CompressedNonExistenceProof"))
		}
		panic(fmt.Errorf("message ics23.CompressedNonExistenceProof does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_CompressedNonExistenceProof) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ics23.CompressedNonExistenceProof", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_CompressedNonExistenceProof) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CompressedNonExistenceProof) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_CompressedNonExistenceProof) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_CompressedNonExistenceProof) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*CompressedNonExistenceProof)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Key)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Left != nil {
			l = options.Size(x.Left)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Right != nil {
			l = options.Size(x.Right)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*CompressedNonExistenceProof)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Right != nil {
			encoded, err := options.Marshal(x.Right)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if x.Left != nil {
			encoded, err := options.Marshal(x.Left)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Key) > 0 {
			i -= len(x.Key)
			copy(dAtA[i:], x.Key)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Key)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*CompressedNonExistenceProof)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CompressedNonExistenceProof: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CompressedNonExistenceProof: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Key = append(x.Key[:0], dAtA[iNdEx:postIndex]...)
				if x.Key == nil {
					x.Key = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Left == nil {
					x.Left = &CompressedExistenceProof{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Left); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Right == nil {
					x.Right = &CompressedExistenceProof{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Right); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: proofs.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type HashOp int32

const (
	// NO_HASH is the default if no data passed. Note this is an illegal argument some places.
	HashOp_NO_HASH    HashOp = 0
	HashOp_SHA256     HashOp = 1
	HashOp_SHA512     HashOp = 2
	HashOp_KECCAK     HashOp = 3
	HashOp_RIPEMD160  HashOp = 4
	HashOp_BITCOIN    HashOp = 5 // ripemd160(sha256(x))
	HashOp_SHA512_256 HashOp = 6
)

// Enum value maps for HashOp.
var (
	HashOp_name = map[int32]string{
		0: "NO_HASH",
		1: "SHA256",
		2: "SHA512",
		3: "KECCAK",
		4: "RIPEMD160",
		5: "BITCOIN",
		6: "SHA512_256",
	}
	HashOp_value = map[string]int32{
		"NO_HASH":    0,
		"SHA256":     1,
		"SHA512":     2,
		"KECCAK":     3,
		"RIPEMD160":  4,
		"BITCOIN":    5,
		"SHA512_256": 6,
	}
)

func (x HashOp) Enum() *HashOp {
	p := new(HashOp)
	*p = x
	return p
}

func (x HashOp) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HashOp) Descriptor() protoreflect.EnumDescriptor {
	return file_proofs_proto_enumTypes[0].Descriptor()
}

func (HashOp) Type() protoreflect.EnumType {
	return &file_proofs_proto_enumTypes[0]
}

func (x HashOp) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HashOp.Descriptor instead.
func (HashOp) EnumDescriptor() ([]byte, []int) {
	return file_proofs_proto_rawDescGZIP(), []int{0}
}

// LengthOp defines how to process the key and value of the LeafOp
// to include length information. After encoding the length with the given
// algorithm, the length will be prepended to the key and value bytes.
// (Each one with it's own encoded length)
type LengthOp int32

const (
	// NO_PREFIX don't include any length info
	LengthOp_NO_PREFIX LengthOp = 0
	// VAR_PROTO uses protobuf (and go-amino) varint encoding of the length
	LengthOp_VAR_PROTO LengthOp = 1
	// VAR_RLP uses rlp int encoding of the length
	LengthOp_VAR_RLP LengthOp = 2
	// FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer
	LengthOp_FIXED32_BIG LengthOp = 3
	// FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer
	LengthOp_FIXED32_LITTLE LengthOp = 4
	// FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer
	LengthOp_FIXED64_BIG LengthOp = 5
	// FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer
	LengthOp_FIXED64_LITTLE LengthOp = 6
	// REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
	LengthOp_REQUIRE_32_BYTES LengthOp = 7
	// REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
	LengthOp_REQUIRE_64_BYTES LengthOp = 8
)

// Enum value maps for LengthOp.
var (
	LengthOp_name = map[int32]string{
		0: "NO_PREFIX",
		1: "VAR_PROTO",
		2: "VAR_RLP",
		3: "FIXED32_BIG",
		4: "FIXED32_LITTLE",
		5: "FIXED64_BIG",
		6: "FIXED64_LITTLE",
		7: "REQUIRE_32_BYTES",
		8: "REQUIRE_64_BYTES",
	}
	LengthOp_value = map[string]int32{
		"NO_PREFIX":        0,
		"VAR_PROTO":        1,
		"VAR_RLP":          2,
		"FIXED32_BIG":      3,
		"FIXED32_LITTLE":   4,
		"FIXED64_BIG":      5,
		"FIXED64_LITTLE":   6,
		"REQUIRE_32_BYTES": 7,
		"REQUIRE_64_BYTES": 8,
	}
)

func (x LengthOp) Enum() *LengthOp {
	p := new(LengthOp)
	*p = x
	return p
}

func (x LengthOp) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LengthOp) Descriptor() protoreflect.EnumDescriptor {
	return file_proofs_proto_enumTypes[1].Descriptor()
}

func (LengthOp) Type() protoreflect.EnumType {
	return &file_proofs_proto_enumTypes[1]
}

func (x LengthOp) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LengthOp.Descriptor instead.
func (LengthOp) EnumDescriptor() ([]byte, []int) {
	return file_proofs_proto_rawDescGZIP(), []int{1}
}

// ExistenceProof takes a key and a value and a set of steps to perform on it.
// The result of peforming all these steps will provide a "root hash", which can
// be compared to the value in a header.
// Since it is computationally infeasible to produce a hash collission for any of the used
// cryptographic hash functions, if someone can provide a series of operations to transform
// a given key and value into a root hash that matches some trusted root, these key and values
// must be in the referenced merkle tree.
// The only possible issue is maliablity in LeafOp, such as providing extra prefix data,
// which should be controlled by a spec. Eg. with lengthOp as NONE,
// prefix = FOO, key = BAR, value = CHOICE
// and
// prefix = F, key = OOBAR, value = CHOICE
// would produce the same value.
// With LengthOp this is tricker but not impossible. Which is why the "leafPrefixEqual" field
// in the ProofSpec is valuable to prevent this mutability. And why all trees should
// length-prefix the data before hashing it.
type ExistenceProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key   []byte     `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value []byte     `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Leaf  *LeafOp    `protobuf:"bytes,3,opt,name=leaf,proto3" json:"leaf,omitempty"`
	Path  []*InnerOp `protobuf:"bytes,4,rep,name=path,proto3" json:"path,omitempty"`
}

func (x *ExistenceProof) Reset() {
	*x = ExistenceProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proofs_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExistenceProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExistenceProof) ProtoMessage() {}

// Deprecated: Use ExistenceProof.ProtoReflect.Descriptor instead.
func (*ExistenceProof) Descriptor() ([]byte, []int) {
	return file_proofs_proto_rawDescGZIP(), []int{0}
}

func (x *ExistenceProof) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *ExistenceProof) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *ExistenceProof) GetLeaf() *LeafOp {
	if x != nil {
		return x.Leaf
	}
	return nil
}

func (x *ExistenceProof) GetPath() []*InnerOp {
	if x != nil {
		return x.Path
	}
	return nil
}

// NonExistenceProof takes a proof of two neighbors, one left of the desired key,
// one right of the desired key. If both proofs are valid AND they are neighbors,
// then there is no valid proof for the given key.
type NonExistenceProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key   []byte          `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"` // TODO: remove this as unnecessary??? we prove a range
	Left  *ExistenceProof `protobuf:"bytes,2,opt,name=left,proto3" json:"left,omitempty"`
	Right *ExistenceProof `protobuf:"bytes,3,opt,name=right,proto3" json:"right,omitempty"`
}

func (x *NonExistenceProof) Reset() {
	*x = NonExistenceProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proofs_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NonExistenceProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NonExistenceProof) ProtoMessage() {}

// Deprecated: Use NonExistenceProof.ProtoReflect.Descriptor instead.
func (*NonExistenceProof) Descriptor() ([]byte, []int) {
	return file_proofs_proto_rawDescGZIP(), []int{1}
}

func (x *NonExistenceProof) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *NonExistenceProof) GetLeft() *ExistenceProof {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *NonExistenceProof) GetRight() *ExistenceProof {
	if x != nil {
		return x.Right
	}
	return nil
}

// CommitmentProof is either an ExistenceProof or a NonExistenceProof, or a Batch of such messages
type CommitmentProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Proof:
	//
	//	*CommitmentProof_Exist
	//	*CommitmentProof_Nonexist
	//	*CommitmentProof_Batch
	//	*CommitmentProof_Compressed
	Proof isCommitmentProof_Proof `protobuf_oneof:"proof"`
}

func (x *CommitmentProof) Reset() {
	*x = CommitmentProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proofs_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommitmentProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitmentProof) ProtoMessage() {}

// Deprecated: Use CommitmentProof.ProtoReflect.Descriptor instead.
func (*CommitmentProof) Descriptor() ([]byte, []int) {
	return file_proofs_proto_rawDescGZIP(), []int{2}
}

func (x *CommitmentProof) GetProof() isCommitmentProof_Proof {
	if x != nil {
		return x.Proof
	}
	return nil
}

func (x *CommitmentProof) GetExist() *ExistenceProof {
	if x, ok := x.GetProof().(*CommitmentProof_Exist); ok {
		return x.Exist
	}
	return nil
}

func (x *CommitmentProof) GetNonexist() *NonExistenceProof {
	if x, ok := x.GetProof().(*CommitmentProof_Nonexist); ok {
		return x.Nonexist
	}
	return nil
}

func (x *CommitmentProof) GetBatch() *BatchProof {
	if x, ok := x.GetProof().(*CommitmentProof_Batch); ok {
		return x.Batch
	}
	return nil
}

func (x *CommitmentProof) GetCompressed() *CompressedBatchProof {
	if x, ok := x.GetProof().(*CommitmentProof_Compressed); ok {
		return x.Compressed
	}
	return nil
}

type isCommitmentProof_Proof interface {
	isCommitmentProof_Proof()
}

type CommitmentProof_Exist struct {
	Exist *ExistenceProof `protobuf:"bytes,1,opt,name=exist,proto3,oneof"`
}

type CommitmentProof_Nonexist struct {
	Nonexist *NonExistenceProof `protobuf:"bytes,2,opt,name=nonexist,proto3,oneof"`
}

type CommitmentProof_Batch struct {
	Batch *BatchProof `protobuf:"bytes,3,opt,name=batch,proto3,oneof"`
}

type CommitmentProof_Compressed struct {
	Compressed *CompressedBatchProof `protobuf:"bytes,4,opt,name=compressed,proto3,oneof"`
}

func (*CommitmentProof_Exist) isCommitmentProof_Proof() {}

func (*CommitmentProof_Nonexist) isCommitmentProof_Proof() {}

func (*CommitmentProof_Batch) isCommitmentProof_Proof() {}

func (*CommitmentProof_Compressed) isCommitmentProof_Proof() {}

// LeafOp represents the raw key-value data we wish to prove, and
// must be flexible to represent the internal transformation from
// the original key-value pairs into the basis hash, for many existing
// merkle trees.
// key and value are passed in. So that the signature of this operation is:
// leafOp(key, value) -> output
// To process this, first prehash the keys and values if needed (ANY means no hash in this case):
// hkey = prehashKey(key)
// hvalue = prehashValue(value)
// Then combine the bytes, and hash it
// output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)
type LeafOp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Hash         HashOp   `protobuf:"varint,1,opt,name=hash,proto3,enum=ics23.HashOp" json:"hash,omitempty"`
	PrehashKey   HashOp   `protobuf:"varint,2,opt,name=prehash_key,json=prehashKey,proto3,enum=ics23.HashOp" json:"prehash_key,omitempty"`
	PrehashValue HashOp   `protobuf:"varint,3,opt,name=prehash_value,json=prehashValue,proto3,enum=ics23.HashOp" json:"prehash_value,omitempty"`
	Length       LengthOp `protobuf:"varint,4,opt,name=length,proto3,enum=ics23.LengthOp" json:"length,omitempty"`
	// prefix is a fixed bytes that may optionally be included at the beginning to differentiate
	// a leaf node from an inner node.
	Prefix []byte `protobuf:"bytes,5,opt,name=prefix,proto3" json:"prefix,omitempty"`
}

func (x *LeafOp) Reset() {
	*x = LeafOp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proofs_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LeafOp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LeafOp) ProtoMessage() {}

// Deprecated: Use LeafOp.ProtoReflect.Descriptor instead.
func (*LeafOp) Descriptor() ([]byte, []int) {
	return file_proofs_proto_rawDescGZIP(), []int{3}
}

func (x *LeafOp) GetHash() HashOp {
	if x != nil {
		return x.Hash
	}
	return HashOp_NO_HASH
}

func (x *LeafOp) GetPrehashKey() HashOp {
	if x != nil {
		return x.PrehashKey
	}
	return HashOp_NO_HASH
}

func (x *LeafOp) GetPrehashValue() HashOp {
	if x != nil {
		return x.PrehashValue
	}
	return HashOp_NO_HASH
}

func (x *LeafOp) GetLength() LengthOp {
	if x != nil {
		return x.Length
	}
	return LengthOp_NO_PREFIX
}

func (x *LeafOp) GetPrefix() []byte {
	if x != nil {
		return x.Prefix
	}
	return nil
}

// InnerOp represents a merkle-proof step that is not a leaf.
// It represents concatenating two children and hashing them to provide the next result.
// The result of the previous step is passed in, so the signature of this op is:
// innerOp(child) -> output
// The result of applying InnerOp should be:
// output = op.hash(op.prefix || child || op.suffix)
// where the || operator is concatenation of binary data,
// and child is the result of hashing all the tree below this step.
// Any special data, like prepending child with the length, or prepending the entire operation with
// some value to differentiate from leaf nodes, should be included in prefix and suffix.
// If either of prefix or suffix is empty, we just treat it as an empty string
type InnerOp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Hash   HashOp `protobuf:"varint,1,opt,name=hash,proto3,enum=ics23.HashOp" json:"hash,omitempty"`
	Prefix []byte `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Suffix []byte `protobuf:"bytes,3,opt,name=suffix,proto3" json:"suffix,omitempty"`
}

func (x *InnerOp) Reset() {
	*x = InnerOp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proofs_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *InnerOp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InnerOp) ProtoMessage() {}

// Deprecated: Use InnerOp.ProtoReflect.Descriptor instead.
func (*InnerOp) Descriptor() ([]byte, []int) {
	return file_proofs_proto_rawDescGZIP(), []int{4}
}

func (x *InnerOp) GetHash() HashOp {
	if x != nil {
		return x.Hash
	}
	return HashOp_NO_HASH
}

func (x *InnerOp) GetPrefix() []byte {
	if x != nil {
		return x.Prefix
	}
	return nil
}

func (x *InnerOp) GetSuffix() []byte {
	if x != nil {
		return x.Suffix
	}
	return nil
}

// ProofSpec defines what the expected parameters are for a given proof type.
// This can be stored in the client and used to validate any incoming proofs.
// verify(ProofSpec, Proof) -> Proof | Error
// As demonstrated in tests, if we don't fix the algorithm used to calculate the
// LeafHash for a given tree, there are many possible key-value pairs that can
// generate a given hash (by interpretting the preimage differently).
// We need this for proper security, requires client knows a priori what
// tree format server uses. But not in code, rather a configuration object.
type ProofSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// any field in the ExistenceProof must be the same as in this spec.
	// except Prefix, which is just the first bytes of prefix (spec can be longer)
	LeafSpec  *LeafOp    `protobuf:"bytes,1,opt,name=leaf_spec,json=leafSpec,proto3" json:"leaf_spec,omitempty"`
	InnerSpec *InnerSpec `protobuf:"bytes,2,opt,name=inner_spec,json=innerSpec,proto3" json:"inner_spec,omitempty"`
	// max_depth (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
	MaxDepth int32 `protobuf:"varint,3,opt,name=max_depth,json=maxDepth,proto3" json:"max_depth,omitempty"`
	// min_depth (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
	MinDepth int32 `protobuf:"varint,4,opt,name=min_depth,json=minDepth,proto3" json:"min_depth,omitempty"`
}

func (x *ProofSpec) Reset() {
	*x = ProofSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proofs_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ProofSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProofSpec) ProtoMessage() {}

// Deprecated: Use ProofSpec.ProtoReflect.Descriptor instead.
func (*ProofSpec) Descriptor() ([]byte, []int) {
	return file_proofs_proto_rawDescGZIP(), []int{5}
}

func (x *ProofSpec) GetLeafSpec() *LeafOp {
	if x != nil {
		return x.LeafSpec
	}
	return nil
}

func (x *ProofSpec) GetInnerSpec() *InnerSpec {
	if x != nil {
		return x.InnerSpec
	}
	return nil
}

func (x *ProofSpec) GetMaxDepth() int32 {
	if x != nil {
		return x.MaxDepth
	}
	return 0
}

func (x *ProofSpec) GetMinDepth() int32 {
	if x != nil {
		return x.MinDepth
	}
	return 0
}

// InnerSpec contains all store-specific structure info to determine if two proofs from a
// given store are neighbors.
// This enables:
// isLeftMost(spec: InnerSpec, op: InnerOp)
// isRightMost(spec: InnerSpec, op: InnerOp)
// isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp)
type InnerSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Child order is the ordering of the children node, must count from 0
	// iavl tree is [0, 1] (left then right)
	// merk is [0, 2, 1] (left, right, here)
	ChildOrder      []int32 `protobuf:"varint,1,rep,packed,name=child_order,json=childOrder,proto3" json:"child_order,omitempty"`
	ChildSize       int32   `protobuf:"varint,2,opt,name=child_size,json=childSize,proto3" json:"child_size,omitempty"`
	MinPrefixLength int32   `protobuf:"varint,3,opt,name=min_prefix_length,json=minPrefixLength,proto3" json:"min_prefix_length,omitempty"`
	MaxPrefixLength int32   `protobuf:"varint,4,opt,name=max_prefix_length,json=maxPrefixLength,proto3" json:"max_prefix_length,omitempty"`
	// empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0)
	EmptyChild []byte `protobuf:"bytes,5,opt,name=empty_child,json=emptyChild,proto3" json:"empty_child,omitempty"`
	// hash is the algorithm that must be used for each InnerOp
	Hash HashOp `protobuf:"varint,6,opt,name=hash,proto3,enum=ics23.HashOp" json:"hash,omitempty"`
}

func (x *InnerSpec) Reset() {
	*x = InnerSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proofs_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *InnerSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InnerSpec) ProtoMessage() {}

// Deprecated: Use InnerSpec.ProtoReflect.Descriptor instead.
func (*InnerSpec) Descriptor() ([]byte, []int) {
	return file_proofs_proto_rawDescGZIP(), []int{6}
}

func (x *InnerSpec) GetChildOrder() []int32 {
	if x != nil {
		return x.ChildOrder
	}
	return nil
}

func (x *InnerSpec) GetChildSize() int32 {
	if x != nil {
		return x.ChildSize
	}
	return 0
}

func (x *InnerSpec) GetMinPrefixLength() int32 {
	if x != nil {
		return x.MinPrefixLength
	}
	return 0
}

func (x *InnerSpec) GetMaxPrefixLength() int32 {
	if x != nil {
		return x.MaxPrefixLength
	}
	return 0
}

func (x *InnerSpec) GetEmptyChild() []byte {
	if x != nil {
		return x.EmptyChild
	}
	return nil
}

func (x *InnerSpec) GetHash() HashOp {
	if x != nil {
		return x.Hash
	}
	return HashOp_NO_HASH
}

// BatchProof is a group of multiple proof types than can be compressed
type BatchProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Entries []*BatchEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (x *BatchProof) Reset() {
	*x = BatchProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proofs_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchProof) ProtoMessage() {}

// Deprecated: Use BatchProof.ProtoReflect.Descriptor instead.
func (*BatchProof) Descriptor() ([]byte, []int) {
	return file_proofs_proto_rawDescGZIP(), []int{7}
}

func (x *BatchProof) GetEntries() []*BatchEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

// Use BatchEntry not CommitmentProof, to avoid recursion
type BatchEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Proof:
	//
	//	*BatchEntry_Exist
	//	*BatchEntry_Nonexist
	Proof isBatchEntry_Proof `protobuf_oneof:"proof"`
}

func (x *BatchEntry) Reset() {
	*x = BatchEntry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proofs_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchEntry) ProtoMessage() {}

// Deprecated: Use BatchEntry.ProtoReflect.Descriptor instead.
func (*BatchEntry) Descriptor() ([]byte, []int) {
	return file_proofs_proto_rawDescGZIP(), []int{8}
}

func (x *BatchEntry) GetProof() isBatchEntry_Proof {
	if x != nil {
		return x.Proof
	}
	return nil
}

func (x *BatchEntry) GetExist() *ExistenceProof {
	if x, ok := x.GetProof().(*BatchEntry_Exist); ok {
		return x.Exist
	}
	return nil
}

func (x *BatchEntry) GetNonexist() *NonExistenceProof {
	if x, ok := x.GetProof().(*BatchEntry_Nonexist); ok {
		return x.Nonexist
	}
	return nil
}

type isBatchEntry_Proof interface {
	isBatchEntry_Proof()
}

type BatchEntry_Exist struct {
	Exist *ExistenceProof `protobuf:"bytes,1,opt,name=exist,proto3,oneof"`
}

type BatchEntry_Nonexist struct {
	Nonexist *NonExistenceProof `protobuf:"bytes,2,opt,name=nonexist,proto3,oneof"`
}

func (*BatchEntry_Exist) isBatchEntry_Proof() {}

func (*BatchEntry_Nonexist) isBatchEntry_Proof() {}

type CompressedBatchProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Entries      []*CompressedBatchEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	LookupInners []*InnerOp              `protobuf:"bytes,2,rep,name=lookup_inners,json=lookupInners,proto3" json:"lookup_inners,omitempty"`
}

func (x *CompressedBatchProof) Reset() {
	*x = CompressedBatchProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proofs_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CompressedBatchProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompressedBatchProof) ProtoMessage() {}

// Deprecated: Use CompressedBatchProof.ProtoReflect.Descriptor instead.
func (*CompressedBatchProof) Descriptor() ([]byte, []int) {
	return file_proofs_proto_rawDescGZIP(), []int{9}
}

func (x *CompressedBatchProof) GetEntries() []*CompressedBatchEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

func (x *CompressedBatchProof) GetLookupInners() []*InnerOp {
	if x != nil {
		return x.LookupInners
	}
	return nil
}

// Use BatchEntry not CommitmentProof, to avoid recursion
type CompressedBatchEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Proof:
	//
	//	*CompressedBatchEntry_Exist
	//	*CompressedBatchEntry_Nonexist
	Proof isCompressedBatchEntry_Proof `protobuf_oneof:"proof"`
}

func (x *CompressedBatchEntry) Reset() {
	*x = CompressedBatchEntry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proofs_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CompressedBatchEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompressedBatchEntry) ProtoMessage() {}

// Deprecated: Use CompressedBatchEntry.ProtoReflect.Descriptor instead.
func (*CompressedBatchEntry) Descriptor() ([]byte, []int) {
	return file_proofs_proto_rawDescGZIP(), []int{10}
}

func (x *CompressedBatchEntry) GetProof() isCompressedBatchEntry_Proof {
	if x != nil {
		return x.Proof
	}
	return nil
}

func (x *CompressedBatchEntry) GetExist() *CompressedExistenceProof {
	if x, ok := x.GetProof().(*CompressedBatchEntry_Exist); ok {
		return x.Exist
	}
	return nil
}

func (x *CompressedBatchEntry) GetNonexist() *CompressedNonExistenceProof {
	if x, ok := x.GetProof().(*CompressedBatchEntry_Nonexist); ok {
		return x.Nonexist
	}
	return nil
}

type isCompressedBatchEntry_Proof interface {
	isCompressedBatchEntry_Proof()
}

type CompressedBatchEntry_Exist struct {
	Exist *CompressedExistenceProof `protobuf:"bytes,1,opt,name=exist,proto3,oneof"`
}

type CompressedBatchEntry_Nonexist struct {
	Nonexist *CompressedNonExistenceProof `protobuf:"bytes,2,opt,name=nonexist,proto3,oneof"`
}

func (*CompressedBatchEntry_Exist) isCompressedBatchEntry_Proof() {}

func (*CompressedBatchEntry_Nonexist) isCompressedBatchEntry_Proof() {}

type CompressedExistenceProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key   []byte  `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value []byte  `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Leaf  *LeafOp `protobuf:"bytes,3,opt,name=leaf,proto3" json:"leaf,omitempty"`
	// these are indexes into the lookup_inners table in CompressedBatchProof
	Path []int32 `protobuf:"varint,4,rep,packed,name=path,proto3" json:"path,omitempty"`
}

func (x *CompressedExistenceProof) Reset() {
	*x = CompressedExistenceProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proofs_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CompressedExistenceProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompressedExistenceProof) ProtoMessage() {}

// Deprecated: Use CompressedExistenceProof.ProtoReflect.Descriptor instead.
func (*CompressedExistenceProof) Descriptor() ([]byte, []int) {
	return file_proofs_proto_rawDescGZIP(), []int{11}
}

func (x *CompressedExistenceProof) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *CompressedExistenceProof) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *CompressedExistenceProof) GetLeaf() *LeafOp {
	if x != nil {
		return x.Leaf
	}
	return nil
}

func (x *CompressedExistenceProof) GetPath() []int32 {
	if x != nil {
		return x.Path
	}
	return nil
}

type CompressedNonExistenceProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key   []byte                    `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"` // TODO: remove this as unnecessary??? we prove a range
	Left  *CompressedExistenceProof `protobuf:"bytes,2,opt,name=left,proto3" json:"left,omitempty"`
	Right *CompressedExistenceProof `protobuf:"bytes,3,opt,name=right,proto3" json:"right,omitempty"`
}

func (x *CompressedNonExistenceProof) Reset() {
	*x = CompressedNonExistenceProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proofs_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CompressedNonExistenceProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompressedNonExistenceProof) ProtoMessage() {}

// Deprecated: Use CompressedNonExistenceProof.ProtoReflect.Descriptor instead.
func (*CompressedNonExistenceProof) Descriptor() ([]byte, []int) {
	return file_proofs_proto_rawDescGZIP(), []int{12}
}

func (x *CompressedNonExistenceProof) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *CompressedNonExistenceProof) GetLeft() *CompressedExistenceProof {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *CompressedNonExistenceProof) GetRight() *CompressedExistenceProof {
	if x != nil {
		return x.Right
	}
	return nil
}

var File_proofs_proto protoreflect.FileDescriptor

var file_proofs_proto_rawDesc = []byte{
	0x0a, 0x0c, 0x70, 0x72, 0x6f, 0x6f, 0x66, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x05,
	0x69, 0x63, 0x73, 0x32, 0x33, 0x22, 0x7f, 0x0a, 0x0e, 0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e,
	0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x12,
	0x21, 0x0a, 0x04, 0x6c, 0x65, 0x61, 0x66, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e,
	0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x4c, 0x65, 0x61, 0x66, 0x4f, 0x70, 0x52, 0x04, 0x6c, 0x65,
	0x61, 0x66, 0x12, 0x22, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x0e, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x4f, 0x70,
	0x52, 0x04, 0x70, 0x61, 0x74, 0x68, 0x22, 0x7d, 0x0a, 0x11, 0x4e, 0x6f, 0x6e, 0x45, 0x78, 0x69,
	0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x12, 0x10, 0x0a, 0x03, 0x6b,
	0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x29, 0x0a,
	0x04, 0x6c, 0x65, 0x66, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x69, 0x63,
	0x73, 0x32, 0x33, 0x2e, 0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f,
	0x6f, 0x66, 0x52, 0x04, 0x6c, 0x65, 0x66, 0x74, 0x12, 0x2b, 0x0a, 0x05, 0x72, 0x69, 0x67, 0x68,
	0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e,
	0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x52, 0x05,
	0x72, 0x69, 0x67, 0x68, 0x74, 0x22, 0xeb, 0x01, 0x0a, 0x0f, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74,
	0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x12, 0x2d, 0x0a, 0x05, 0x65, 0x78, 0x69,
	0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33,
	0x2e, 0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x48,
	0x00, 0x52, 0x05, 0x65, 0x78, 0x69, 0x73, 0x74, 0x12, 0x36, 0x0a, 0x08, 0x6e, 0x6f, 0x6e, 0x65,
	0x78, 0x69, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x69, 0x63, 0x73,
	0x32, 0x33, 0x2e, 0x4e, 0x6f, 0x6e, 0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50,
	0x72, 0x6f, 0x6f, 0x66, 0x48, 0x00, 0x52, 0x08, 0x6e, 0x6f, 0x6e, 0x65, 0x78, 0x69, 0x73, 0x74,
	0x12, 0x29, 0x0a, 0x05, 0x62, 0x61, 0x74, 0x63, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x11, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x50, 0x72, 0x6f,
	0x6f, 0x66, 0x48, 0x00, 0x52, 0x05, 0x62, 0x61, 0x74, 0x63, 0x68, 0x12, 0x3d, 0x0a, 0x0a, 0x63,
	0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1b, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73,
	0x65, 0x64, 0x42, 0x61, 0x74, 0x63, 0x68, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x48, 0x00, 0x52, 0x0a,
	0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x42, 0x07, 0x0a, 0x05, 0x70, 0x72,
	0x6f, 0x6f, 0x66, 0x22, 0xd0, 0x01, 0x0a, 0x06, 0x4c, 0x65, 0x61, 0x66, 0x4f, 0x70, 0x12, 0x21,
	0x0a, 0x04, 0x68, 0x61, 0x73, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0d, 0x2e, 0x69,
	0x63, 0x73, 0x32, 0x33, 0x2e, 0x48, 0x61, 0x73, 0x68, 0x4f, 0x70, 0x52, 0x04, 0x68, 0x61, 0x73,
	0x68, 0x12, 0x2e, 0x0a, 0x0b, 0x70, 0x72, 0x65, 0x68, 0x61, 0x73, 0x68, 0x5f, 0x6b, 0x65, 0x79,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0d, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x48,
	0x61, 0x73, 0x68, 0x4f, 0x70, 0x52, 0x0a, 0x70, 0x72, 0x65, 0x68, 0x61, 0x73, 0x68, 0x4b, 0x65,
	0x79, 0x12, 0x32, 0x0a, 0x0d, 0x70, 0x72, 0x65, 0x68, 0x61, 0x73, 0x68, 0x5f, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0d, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33,
	0x2e, 0x48, 0x61, 0x73, 0x68, 0x4f, 0x70, 0x52, 0x0c, 0x70, 0x72, 0x65, 0x68, 0x61, 0x73, 0x68,
	0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x27, 0x0a, 0x06, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0f, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x4c, 0x65,
	0x6e, 0x67, 0x74, 0x68, 0x4f, 0x70, 0x52, 0x06, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x12, 0x16,
	0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x06,
	0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x22, 0x5c, 0x0a, 0x07, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x4f,
	0x70, 0x12, 0x21, 0x0a, 0x04, 0x68, 0x61, 0x73, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x0d, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x48, 0x61, 0x73, 0x68, 0x4f, 0x70, 0x52, 0x04,
	0x68, 0x61, 0x73, 0x68, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x16, 0x0a, 0x06,
	0x73, 0x75, 0x66, 0x66, 0x69, 0x78, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x06, 0x73, 0x75,
	0x66, 0x66, 0x69, 0x78, 0x22, 0xa2, 0x01, 0x0a, 0x09, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x53, 0x70,
	0x65, 0x63, 0x12, 0x2a, 0x0a, 0x09, 0x6c, 0x65, 0x61, 0x66, 0x5f, 0x73, 0x70, 0x65, 0x63, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x4c, 0x65,
	0x61, 0x66, 0x4f, 0x70, 0x52, 0x08, 0x6c, 0x65, 0x61, 0x66, 0x53, 0x70, 0x65, 0x63, 0x12, 0x2f,
	0x0a, 0x0a, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x5f, 0x73, 0x70, 0x65, 0x63, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x10, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x49, 0x6e, 0x6e, 0x65, 0x72,
	0x53, 0x70, 0x65, 0x63, 0x52, 0x09, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x53, 0x70, 0x65, 0x63, 0x12,
	0x1b, 0x0a, 0x09, 0x6d, 0x61, 0x78, 0x5f, 0x64, 0x65, 0x70, 0x74, 0x68, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x08, 0x6d, 0x61, 0x78, 0x44, 0x65, 0x70, 0x74, 0x68, 0x12, 0x1b, 0x0a, 0x09,
	0x6d, 0x69, 0x6e, 0x5f, 0x64, 0x65, 0x70, 0x74, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x08, 0x6d, 0x69, 0x6e, 0x44, 0x65, 0x70, 0x74, 0x68, 0x22, 0xe7, 0x01, 0x0a, 0x09, 0x49, 0x6e,
	0x6e, 0x65, 0x72, 0x53, 0x70, 0x65, 0x63, 0x12, 0x1f, 0x0a, 0x0b, 0x63, 0x68, 0x69, 0x6c, 0x64,
	0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x0a, 0x63, 0x68,
	0x69, 0x6c, 0x64, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x68, 0x69, 0x6c,
	0x64, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09, 0x63, 0x68,
	0x69, 0x6c, 0x64, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x2a, 0x0a, 0x11, 0x6d, 0x69, 0x6e, 0x5f, 0x70,
	0x72, 0x65, 0x66, 0x69, 0x78, 0x5f, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x0f, 0x6d, 0x69, 0x6e, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x4c, 0x65, 0x6e,
	0x67, 0x74, 0x68, 0x12, 0x2a, 0x0a, 0x11, 0x6d, 0x61, 0x78, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x69,
	0x78, 0x5f, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0f,
	0x6d, 0x61, 0x78, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x12,
	0x1f, 0x0a, 0x0b, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x5f, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x0a, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x43, 0x68, 0x69, 0x6c, 0x64,
	0x12, 0x21, 0x0a, 0x04, 0x68, 0x61, 0x73, 0x68, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0d,
	0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x48, 0x61, 0x73, 0x68, 0x4f, 0x70, 0x52, 0x04, 0x68,
	0x61, 0x73, 0x68, 0x22, 0x39, 0x0a, 0x0a, 0x42, 0x61, 0x74, 0x63, 0x68, 0x50, 0x72, 0x6f, 0x6f,
	0x66, 0x12, 0x2b, 0x0a, 0x07, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x11, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68,
	0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x22, 0x7c,
	0x0a, 0x0a, 0x42, 0x61, 0x74, 0x63, 0x68, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x2d, 0x0a, 0x05,
	0x65, 0x78, 0x69, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x69, 0x63,
	0x73, 0x32, 0x33, 0x2e, 0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f,
	0x6f, 0x66, 0x48, 0x00, 0x52, 0x05, 0x65, 0x78, 0x69, 0x73, 0x74, 0x12, 0x36, 0x0a, 0x08, 0x6e,
	0x6f, 0x6e, 0x65, 0x78, 0x69, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e,
	0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x4e, 0x6f, 0x6e, 0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e,
	0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x48, 0x00, 0x52, 0x08, 0x6e, 0x6f, 0x6e, 0x65, 0x78,
	0x69, 0x73, 0x74, 0x42, 0x07, 0x0a, 0x05, 0x70, 0x72, 0x6f, 0x6f, 0x66, 0x22, 0x82, 0x01, 0x0a,
	0x14, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x42, 0x61, 0x74, 0x63, 0x68,
	0x50, 0x72, 0x6f, 0x6f, 0x66, 0x12, 0x35, 0x0a, 0x07, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73,
	0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x43,
	0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x42, 0x61, 0x74, 0x63, 0x68, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x52, 0x07, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x12, 0x33, 0x0a, 0x0d,
	0x6c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x5f, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x49, 0x6e, 0x6e, 0x65,
	0x72, 0x4f, 0x70, 0x52, 0x0c, 0x6c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x49, 0x6e, 0x6e, 0x65, 0x72,
	0x73, 0x22, 0x9a, 0x01, 0x0a, 0x14, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64,
	0x42, 0x61, 0x74, 0x63, 0x68, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x37, 0x0a, 0x05, 0x65, 0x78,
	0x69, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x69, 0x63, 0x73, 0x32,
	0x33, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x45, 0x78, 0x69, 0x73,
	0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x48, 0x00, 0x52, 0x05, 0x65, 0x78,
	0x69, 0x73, 0x74, 0x12, 0x40, 0x0a, 0x08, 0x6e, 0x6f, 0x6e, 0x65, 0x78, 0x69, 0x73, 0x74, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x43, 0x6f,
	0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x4e, 0x6f, 0x6e, 0x45, 0x78, 0x69, 0x73, 0x74,
	0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x48, 0x00, 0x52, 0x08, 0x6e, 0x6f, 0x6e,
	0x65, 0x78, 0x69, 0x73, 0x74, 0x42, 0x07, 0x0a, 0x05, 0x70, 0x72, 0x6f, 0x6f, 0x66, 0x22, 0x79,
	0x0a, 0x18, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x45, 0x78, 0x69, 0x73,
	0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65,
	0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05,
	0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x12, 0x21, 0x0a, 0x04, 0x6c, 0x65, 0x61, 0x66, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x0d, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x4c, 0x65, 0x61, 0x66, 0x4f, 0x70, 0x52,
	0x04, 0x6c, 0x65, 0x61, 0x66, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x04, 0x20,
	0x03, 0x28, 0x05, 0x52, 0x04, 0x70, 0x61, 0x74, 0x68, 0x22, 0x9b, 0x01, 0x0a, 0x1b, 0x43, 0x6f,
	0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x4e, 0x6f, 0x6e, 0x45, 0x78, 0x69, 0x73, 0x74,
	0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x33, 0x0a, 0x04, 0x6c,
	0x65, 0x66, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x69, 0x63, 0x73, 0x32,
	0x33, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x45, 0x78, 0x69, 0x73,
	0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x52, 0x04, 0x6c, 0x65, 0x66, 0x74,
	0x12, 0x35, 0x0a, 0x05, 0x72, 0x69, 0x67, 0x68, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1f, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73,
	0x65, 0x64, 0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66,
	0x52, 0x05, 0x72, 0x69, 0x67, 0x68, 0x74, 0x2a, 0x65, 0x0a, 0x06, 0x48, 0x61, 0x73, 0x68, 0x4f,
	0x70, 0x12, 0x0b, 0x0a, 0x07, 0x4e, 0x4f, 0x5f, 0x48, 0x41, 0x53, 0x48, 0x10, 0x00, 0x12, 0x0a,
	0x0a, 0x06, 0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x10, 0x01, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x48,
	0x41, 0x35, 0x31, 0x32, 0x10, 0x02, 0x12, 0x0a, 0x0a, 0x06, 0x4b, 0x45, 0x43, 0x43, 0x41, 0x4b,
	0x10, 0x03, 0x12, 0x0d, 0x0a, 0x09, 0x52, 0x49, 0x50, 0x45, 0x4d, 0x44, 0x31, 0x36, 0x30, 0x10,
	0x04, 0x12, 0x0b, 0x0a, 0x07, 0x42, 0x49, 0x54, 0x43, 0x4f, 0x49, 0x4e, 0x10, 0x05, 0x12, 0x0e,
	0x0a, 0x0a, 0x53, 0x48, 0x41, 0x35, 0x31, 0x32, 0x5f, 0x32, 0x35, 0x36, 0x10, 0x06, 0x2a, 0xab,
	0x01, 0x0a, 0x08, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x4f, 0x70, 0x12, 0x0d, 0x0a, 0x09, 0x4e,
	0x4f, 0x5f, 0x50, 0x52, 0x45, 0x46, 0x49, 0x58, 0x10, 0x00, 0x12, 0x0d, 0x0a, 0x09, 0x56, 0x41,
	0x52, 0x5f, 0x50, 0x52, 0x4f, 0x54, 0x4f, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x56, 0x41, 0x52,
	0x5f, 0x52, 0x4c, 0x50, 0x10, 0x02, 0x12, 0x0f, 0x0a, 0x0b, 0x46, 0x49, 0x58, 0x45, 0x44, 0x33,
	0x32, 0x5f, 0x42, 0x49, 0x47, 0x10, 0x03, 0x12, 0x12, 0x0a, 0x0e, 0x46, 0x49, 0x58, 0x45, 0x44,
	0x33, 0x32, 0x5f, 0x4c, 0x49, 0x54, 0x54, 0x4c, 0x45, 0x10, 0x04, 0x12, 0x0f, 0x0a, 0x0b, 0x46,
	0x49, 0x58, 0x45, 0x44, 0x36, 0x34, 0x5f, 0x42, 0x49, 0x47, 0x10, 0x05, 0x12, 0x12, 0x0a, 0x0e,
	0x46, 0x49, 0x58, 0x45, 0x44, 0x36, 0x34, 0x5f, 0x4c, 0x49, 0x54, 0x54, 0x4c, 0x45, 0x10, 0x06,
	0x12, 0x14, 0x0a, 0x10, 0x52, 0x45, 0x51, 0x55, 0x49, 0x52, 0x45, 0x5f, 0x33, 0x32, 0x5f, 0x42,
	0x59, 0x54, 0x45, 0x53, 0x10, 0x07, 0x12, 0x14, 0x0a, 0x10, 0x52, 0x45, 0x51, 0x55, 0x49, 0x52,
	0x45, 0x5f, 0x36, 0x34, 0x5f, 0x42, 0x59, 0x54, 0x45, 0x53, 0x10, 0x08, 0x42, 0x5e, 0x0a, 0x09,
	0x63, 0x6f, 0x6d, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x42, 0x0b, 0x50, 0x72, 0x6f, 0x6f, 0x66,
	0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x10, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x61, 0x70, 0x69, 0xa2, 0x02, 0x03, 0x49, 0x58, 0x58,
	0xaa, 0x02, 0x05, 0x49, 0x63, 0x73, 0x32, 0x33, 0xca, 0x02, 0x05, 0x49, 0x63, 0x73, 0x32, 0x33,
	0xe2, 0x02, 0x11, 0x49, 0x63, 0x73, 0x32, 0x33, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x05, 0x49, 0x63, 0x73, 0x32, 0x33, 0x62, 0x06, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_proofs_proto_rawDescOnce sync.Once
	file_proofs_proto_rawDescData = file_proofs_proto_rawDesc
)

func file_proofs_proto_rawDescGZIP() []byte {
	file_proofs_proto_rawDescOnce.Do(func() {
		file_proofs_proto_rawDescData = protoimpl.X.CompressGZIP(file_proofs_proto_rawDescData)
	})
	return file_proofs_proto_rawDescData
}

var file_proofs_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_proofs_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_proofs_proto_goTypes = []interface{}{
	(HashOp)(0),                         // 0: ics23.HashOp
	(LengthOp)(0),                       // 1: ics23.LengthOp
	(*ExistenceProof)(nil),              // 2: ics23.ExistenceProof
	(*NonExistenceProof)(nil),           // 3: ics23.NonExistenceProof
	(*CommitmentProof)(nil),             // 4: ics23.CommitmentProof
	(*LeafOp)(nil),                      // 5: ics23.LeafOp
	(*InnerOp)(nil),                     // 6: ics23.InnerOp
	(*ProofSpec)(nil),                   // 7: ics23.ProofSpec
	(*InnerSpec)(nil),                   // 8: ics23.InnerSpec
	(*BatchProof)(nil),                  // 9: ics23.BatchProof
	(*BatchEntry)(nil),                  // 10: ics23.BatchEntry
	(*CompressedBatchProof)(nil),        // 11: ics23.CompressedBatchProof
	(*CompressedBatchEntry)(nil),        // 12: ics23.CompressedBatchEntry
	(*CompressedExistenceProof)(nil),    // 13: ics23.CompressedExistenceProof
	(*CompressedNonExistenceProof)(nil), // 14: ics23.CompressedNonExistenceProof
}
var file_proofs_proto_depIdxs = []int32{
	5,  // 0: ics23.ExistenceProof.leaf:type_name -> ics23.LeafOp
	6,  // 1: ics23.ExistenceProof.path:type_name -> ics23.InnerOp
	2,  // 2: ics23.NonExistenceProof.left:type_name -> ics23.ExistenceProof
	2,  // 3: ics23.NonExistenceProof.right:type_name -> ics23.ExistenceProof
	2,  // 4: ics23.CommitmentProof.exist:type_name -> ics23.ExistenceProof
	3,  // 5: ics23.CommitmentProof.nonexist:type_name -> ics23.NonExistenceProof
	9,  // 6: ics23.CommitmentProof.batch:type_name -> ics23.BatchProof
	11, // 7: ics23.CommitmentProof.compressed:type_name -> ics23.CompressedBatchProof
	0,  // 8: ics23.LeafOp.hash:type_name -> ics23.HashOp
	0,  // 9: ics23.LeafOp.prehash_key:type_name -> ics23.HashOp
	0,  // 10: ics23.LeafOp.prehash_value:type_name -> ics23.HashOp
	1,  // 11: ics23.LeafOp.length:type_name -> ics23.LengthOp
	0,  // 12: ics23.InnerOp.hash:type_name -> ics23.HashOp
	5,  // 13: ics23.ProofSpec.leaf_spec:type_name -> ics23.LeafOp
	8,  // 14: ics23.ProofSpec.inner_spec:type_name -> ics23.InnerSpec
	0,  // 15: ics23.InnerSpec.hash:type_name -> ics23.HashOp
	10, // 16: ics23.BatchProof.entries:type_name -> ics23.BatchEntry
	2,  // 17: ics23.BatchEntry.exist:type_name -> ics23.ExistenceProof
	3,  // 18: ics23.BatchEntry.nonexist:type_name -> ics23.NonExistenceProof
	12, // 19: ics23.CompressedBatchProof.entries:type_name -> ics23.CompressedBatchEntry
	6,  // 20: ics23.CompressedBatchProof.lookup_inners:type_name -> ics23.InnerOp
	13, // 21: ics23.CompressedBatchEntry.exist:type_name -> ics23.CompressedExistenceProof
	14, // 22: ics23.CompressedBatchEntry.nonexist:type_name -> ics23.CompressedNonExistenceProof
	5,  // 23: ics23.CompressedExistenceProof.leaf:type_name -> ics23.LeafOp
	13, // 24: ics23.CompressedNonExistenceProof.left:type_name -> ics23.CompressedExistenceProof
	13, // 25: ics23.CompressedNonExistenceProof.right:type_name -> ics23.CompressedExistenceProof
	26, // [26:26] is the sub-list for method output_type
	26, // [26:26] is the sub-list for method input_type
	26, // [26:26] is the sub-list for extension type_name
	26, // [26:26] is the sub-list for extension extendee
	0,  // [0:26] is the sub-list for field type_name
}

func init() { file_proofs_proto_init() }
func file_proofs_proto_init() {
	if File_proofs_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_proofs_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExistenceProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proofs_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NonExistenceProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proofs_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommitmentProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proofs_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LeafOp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proofs_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*InnerOp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proofs_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ProofSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proofs_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*InnerSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proofs_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proofs_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchEntry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proofs_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CompressedBatchProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proofs_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CompressedBatchEntry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proofs_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CompressedExistenceProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proofs_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CompressedNonExistenceProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_proofs_proto_msgTypes[2].OneofWrappers = []interface{}{
		(*CommitmentProof_Exist)(nil),
		(*CommitmentProof_Nonexist)(nil),
		(*CommitmentProof_Batch)(nil),
		(*CommitmentProof_Compressed)(nil),
	}
	file_proofs_proto_msgTypes[8].OneofWrappers = []interface{}{
		(*BatchEntry_Exist)(nil),
		(*BatchEntry_Nonexist)(nil),
	}
	file_proofs_proto_msgTypes[10].OneofWrappers = []interface{}{
		(*CompressedBatchEntry_Exist)(nil),
		(*CompressedBatchEntry_Nonexist)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_proofs_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   13,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proofs_proto_goTypes,
		DependencyIndexes: file_proofs_proto_depIdxs,
		EnumInfos:         file_proofs_proto_enumTypes,
		MessageInfos:      file_proofs_proto_msgTypes,
	}.Build()
	File_proofs_proto = out.File
	file_proofs_proto_rawDesc = nil
	file_proofs_proto_goTypes = nil
	file_proofs_proto_depIdxs = nil
}
