syntax = "proto3";

package ibc.core.channel.v2;

option go_package = "github.com/cosmos/ibc-go/v9/modules/core/04-channel/v2/types";

import "gogoproto/gogo.proto";
import "ibc/core/commitment/v2/commitment.proto";

// Channel defines the channel end on a chain that is implementing the version 2 IBC protocol
// Each side will maintain its own Channel to create an IBC channel
// The channel will be referenced by a channelID which will be used to send packets
// to the counterparty
// The channel will contain the client identifier that will provide proof verification for the channel
// and the counterparty channel identifier that the other channel end will be using
// to send packets to our channel end.
message Channel {
  // the client identifier of the light client representing the counterparty chain
  string client_id = 1;
  // the counterparty identifier that must be used by packets sent by counterparty
  // to our channel end.
  string counterparty_channel_id = 2;
  // the key path used to store packet flow messages that the counterparty
  // will use to send to us. In backwards compatible cases, we will append the channelID and sequence in order to create
  // the final path.
  ibc.core.commitment.v2.MerklePath merkle_path_prefix = 3 [(gogoproto.nullable) = false];
}

// IdentifiedChannel defines a channel with an additional channel identifier field.
message IdentifiedChannel {
  option (gogoproto.goproto_getters) = false;

  // channel identified.
  Channel channel = 1 [(gogoproto.nullable) = false];
  // channel identifier
  string channel_id = 2;
}
