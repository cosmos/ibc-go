"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[61281],{28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>a});var o=t(96540);const s={},i=o.createContext(s);function c(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),o.createElement(i.Provider,{value:n},e.children)}},75599:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>l,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var o=t(74848),s=t(28453);const i={title:"Transaction Encoding",sidebar_label:"Transaction Encoding",sidebar_position:7,slug:"/apps/interchain-accounts/tx-encoding"},c="Transaction Encoding",a={id:"apps/interchain-accounts/tx-encoding",title:"Transaction Encoding",description:"When orchestrating an interchain account transaction, which comprises multiple sdk.Msg objects represented as Any types, the transactions must be encoded as bytes within InterchainAccountPacketData.",source:"@site/docs/02-apps/02-interchain-accounts/07-tx-encoding.md",sourceDirName:"02-apps/02-interchain-accounts",slug:"/apps/interchain-accounts/tx-encoding",permalink:"/main/apps/interchain-accounts/tx-encoding",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{title:"Transaction Encoding",sidebar_label:"Transaction Encoding",sidebar_position:7,slug:"/apps/interchain-accounts/tx-encoding"},sidebar:"defaultSidebar",previous:{title:"Parameters",permalink:"/main/apps/interchain-accounts/parameters"},next:{title:"Client",permalink:"/main/apps/interchain-accounts/client"}},r={},d=[{value:"Protobuf Encoding",id:"protobuf-encoding",level:2},{value:"(Protobuf) JSON Encoding",id:"protobuf-json-encoding",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"transaction-encoding",children:"Transaction Encoding"}),"\n",(0,o.jsxs)(n.p,{children:["When orchestrating an interchain account transaction, which comprises multiple ",(0,o.jsx)(n.code,{children:"sdk.Msg"})," objects represented as ",(0,o.jsx)(n.code,{children:"Any"})," types, the transactions must be encoded as bytes within ",(0,o.jsx)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/v7.2.0/proto/ibc/applications/interchain_accounts/v1/packet.proto#L21-L26",children:(0,o.jsx)(n.code,{children:"InterchainAccountPacketData"})}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-protobuf",children:"// InterchainAccountPacketData is comprised of a raw transaction, type of transaction and optional memo field.\nmessage InterchainAccountPacketData {\n  Type   type = 1;\n  bytes  data = 2;\n  string memo = 3;\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"data"})," field must be encoded as a ",(0,o.jsx)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/v7.2.0/proto/ibc/applications/interchain_accounts/v1/packet.proto#L28-L31",children:(0,o.jsx)(n.code,{children:"CosmosTx"})}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-protobuf",children:"// CosmosTx contains a list of sdk.Msg's. It should be used when sending transactions to an SDK host chain.\nmessage CosmosTx {\n  repeated google.protobuf.Any messages = 1;\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The encoding method for ",(0,o.jsx)(n.code,{children:"CosmosTx"})," is determined during the channel handshake process. If the channel version ",(0,o.jsxs)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/v7.2.0/proto/ibc/applications/interchain_accounts/v1/metadata.proto#L22",children:["metadata's ",(0,o.jsx)(n.code,{children:"encoding"})," field"]})," is marked as ",(0,o.jsx)(n.code,{children:"proto3"}),", then ",(0,o.jsx)(n.code,{children:"CosmosTx"})," undergoes protobuf encoding. Conversely, if the field is set to ",(0,o.jsx)(n.code,{children:"proto3json"}),", then ",(0,o.jsx)(n.a,{href:"https://protobuf.dev/programming-guides/proto3/#json",children:"proto3 json"})," encoding takes place, which generates a JSON representation of the protobuf message."]}),"\n",(0,o.jsx)(n.h2,{id:"protobuf-encoding",children:"Protobuf Encoding"}),"\n",(0,o.jsxs)(n.p,{children:["Protobuf encoding serves as the standard encoding process for ",(0,o.jsx)(n.code,{children:"CosmosTx"}),". This occurs if the channel handshake initiates with an empty channel version metadata or if the ",(0,o.jsx)(n.code,{children:"encoding"})," field explicitly denotes ",(0,o.jsx)(n.code,{children:"proto3"}),". In Golang, the protobuf encoding procedure utilizes the ",(0,o.jsx)(n.code,{children:"proto.Marshal"})," function. Every protobuf autogenerated Golang type comes equipped with a ",(0,o.jsx)(n.code,{children:"Marshal"})," method that can be employed to encode the message."]}),"\n",(0,o.jsx)(n.h2,{id:"protobuf-json-encoding",children:"(Protobuf) JSON Encoding"}),"\n",(0,o.jsxs)(n.p,{children:["The proto3 JSON encoding presents an alternative encoding technique for ",(0,o.jsx)(n.code,{children:"CosmosTx"}),". It is selected if the channel handshake begins with the channel version metadata ",(0,o.jsx)(n.code,{children:"encoding"})," field labeled as ",(0,o.jsx)(n.code,{children:"proto3json"}),". In Golang, the Proto3 canonical encoding in JSON is implemented by the ",(0,o.jsx)(n.code,{children:'"github.com/cosmos/gogoproto/jsonpb"'})," package. Within Cosmos SDK, the ",(0,o.jsx)(n.code,{children:"ProtoCodec"})," structure implements the ",(0,o.jsx)(n.code,{children:"JSONCodec"})," interface, leveraging the ",(0,o.jsx)(n.code,{children:"jsonpb"})," package. This method generates a JSON format as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\n  "messages": [\n    {\n      "@type": "/cosmos.bank.v1beta1.MsgSend",\n      "from_address": "cosmos1...",\n      "to_address": "cosmos1...",\n      "amount": [\n        {\n          "denom": "uatom",\n          "amount": "1000000"\n        }\n      ]\n    }\n  ]\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Here, the ",(0,o.jsx)(n.code,{children:'"messages"'})," array is populated with transactions. Each transaction is represented as a JSON object with the ",(0,o.jsx)(n.code,{children:"@type"})," field denoting the transaction type and the remaining fields representing the transaction's attributes."]}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsxs)(n.p,{children:["When utilizing proto3 JSON encoding, we have extra validations to ensure the integrity of the encoded data. Specifically, after decoding the ",(0,o.jsx)(n.code,{children:"CosmosTx"})," from JSON, we re-encode it back to JSON and compare it with the original input. If non-formatting discrepancies arise, an error is returned. This validation step ensures that the JSON representation remains consistent throughout the encoding and decoding processes. This additional check means that all optional fields must be explicitly set in the JSON input, all enums and integers must be represented as strings."]})})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);