"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[12995],{2510:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>r});var a=t(74848),i=t(28453);const s={title:"IBC v2 Applications",sidebar_label:"IBC v2 Applications",sidebar_position:0,slug:"/ibc/apps/ibcv2apps"},o=void 0,c={id:"ibc/apps/ibcv2apps",title:"IBC v2 Applications",description:"Learn how to implement IBC v2 applications",source:"@site/docs/01-ibc/03-apps/00-ibcv2apps.md",sourceDirName:"01-ibc/03-apps",slug:"/ibc/apps/ibcv2apps",permalink:"/main/ibc/apps/ibcv2apps",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{title:"IBC v2 Applications",sidebar_label:"IBC v2 Applications",sidebar_position:0,slug:"/ibc/apps/ibcv2apps"},sidebar:"defaultSidebar",previous:{title:"Integration",permalink:"/main/ibc/integration"},next:{title:"IBC Applications",permalink:"/main/ibc/apps/apps"}},l={},r=[{value:"Implement the <code>IBCModule</code> interface",id:"implement-the-ibcmodule-interface",level:2},{value:"Packet callbacks",id:"packet-callbacks",level:3},{value:"Sending packets",id:"sending-packets",level:4},{value:"Receiving packets",id:"receiving-packets",level:4},{value:"Acknowledging packets",id:"acknowledging-packets",level:4},{value:"Timeout packets",id:"timeout-packets",level:4},{value:"PacketDataUnmarshaler",id:"packetdataunmarshaler",level:4},{value:"Bind Ports",id:"bind-ports",level:2},{value:"Implement the IBCModule Keeper",id:"implement-the-ibcmodule-keeper",level:2},{value:"Packets and Payloads",id:"packets-and-payloads",level:2},{value:"Routing",id:"routing",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.admonition,{title:"Synopsis",type:"note",children:(0,a.jsx)(n.p,{children:"Learn how to implement IBC v2 applications"})}),"\n",(0,a.jsx)(n.p,{children:"To build an IBC v2 application the following steps are required:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsxs)(n.a,{href:"#implement-the-ibcmodule-interface",children:["Implement the ",(0,a.jsx)(n.code,{children:"IBCModule"})," interface"]})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#bind-ports",children:"Bind Ports"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#implement-the-ibcmodule-keeper",children:"Implement the IBCModule Keeper"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#packets-and-payloads",children:"Implement application payload and success acknowledgement"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#routing",children:"Set and Seal the IBC Router"})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Highlighted improvements for app developers with IBC v2:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"No need to support channel handshake callbacks"}),"\n",(0,a.jsx)(n.li,{children:"Flexibility on upgrading application versioning, no need to use channel upgradability to renegotiate an application version, simply support the application version on both sides of the connection."}),"\n",(0,a.jsx)(n.li,{children:"Flexibility to choose your desired encoding type."}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"implement-the-ibcmodule-interface",children:["Implement the ",(0,a.jsx)(n.code,{children:"IBCModule"})," interface"]}),"\n",(0,a.jsxs)(n.p,{children:["The Cosmos SDK expects all IBC modules to implement the ",(0,a.jsxs)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/api/module.go#L9-L53",children:[(0,a.jsx)(n.code,{children:"IBCModule"}),"\ninterface"]}),". This interface contains all of the callbacks IBC expects modules to implement. Note that for IBC v2, an application developer no longer needs to implement callbacks for the channel handshake. Note that this interface is distinct from the ",(0,a.jsx)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/05-port/types/module.go",children:"porttypes.IBCModule interface"})," used for IBC Classic."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"// IBCModule implements the application interface given the keeper.\n// The implementation of the IBCModule interface could for example be in a file called ibc_module.go,\n// but ultimately file structure is up to the developer\ntype IBCModule struct {\n  keeper keeper.Keeper\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Additionally, in the ",(0,a.jsx)(n.code,{children:"module.go"})," file, add the following line:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"var (\n  _ module.AppModule      = AppModule{}\n  _ module.AppModuleBasic = AppModuleBasic{}\n  // Add this line\n  _ porttypes.IBCModule   = IBCModule{}\n)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"packet-callbacks",children:"Packet callbacks"}),"\n",(0,a.jsxs)(n.p,{children:["IBC expects modules to implement callbacks for handling the packet lifecycle, as defined in the ",(0,a.jsx)(n.code,{children:"IBCModule"})," interface."]}),"\n",(0,a.jsx)(n.p,{children:"With IBC v2, modules are not directly connected. Instead a pair of clients are connected and register the counterparty clientID. Packets are routed to the relevant application module by the portID registered in the Router. Relayers send packets between the routers/packet handlers on each chain."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"IBC packet flow diagram",src:t(50527).A+"",width:"3101",height:"2838"})}),"\n",(0,a.jsx)(n.p,{children:"Briefly, a successful packet flow works as follows:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"A user sends a message to the IBC packet handler"}),"\n",(0,a.jsxs)(n.li,{children:["The IBC packet handler validates the message, creates the packet and stores the commitment and returns the packet sequence number. The ",(0,a.jsx)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/fe25b216359fab71b3228461b05dbcdb1a554158/proto/ibc/core/channel/v2/packet.proto#L26-L38",children:(0,a.jsx)(n.code,{children:"Payload"})}),", which contains application specific data, is routed to the relevant application."]}),"\n",(0,a.jsx)(n.li,{children:"If the counterparty writes an acknowledgement of the packet then the sending chain will process the acknowledgement."}),"\n",(0,a.jsx)(n.li,{children:"If the packet is not successfully received before the timeout, then the sending chain processes the packet's timeout."}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"sending-packets",children:"Sending packets"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel/v2/types/tx.pb.go#L69-L75",children:(0,a.jsx)(n.code,{children:"MsgSendPacket"})})," is sent by a user to the ",(0,a.jsx)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel/v2/keeper/msg_server.go",children:"channel v2 message server"}),", which calls ",(0,a.jsx)(n.code,{children:"ChannelKeeperV2.SendPacket"}),". This validates the message, creates the packet, stores the commitment and returns the packet sequence number. The application must specify its own payload which is used by the application and sent with ",(0,a.jsx)(n.code,{children:"MsgSendPacket"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"An application developer needs to implement the custom logic the application executes when a packet is sent."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"\n// OnSendPacket logic\nfunc (im *IBCModule) OnSendPacket(\n  ctx sdk.Context, \n  sourceChannel string, \n  destinationChannel string, \n  sequence uint64, \n  payload channeltypesv2.Payload, \n  signer sdk.AccAddress) error {\n\n// implement any validation\n\n// implement payload decoding and validation\n\n// call the relevant keeper method for state changes as a result of application logic\n\n// emit events or telemetry data\n\nreturn nil\n}\n\n"})}),"\n",(0,a.jsx)(n.h4,{id:"receiving-packets",children:"Receiving packets"}),"\n",(0,a.jsxs)(n.p,{children:["To handle receiving packets, the module must implement the ",(0,a.jsx)(n.code,{children:"OnRecvPacket"})," callback. An application module should validate and confirm support for the given version and encoding method used as there is greater flexibility in IBC v2 to support a range of versions and encoding methods.\nThe ",(0,a.jsx)(n.code,{children:"OnRecvPacket"})," callback is invoked by the IBC module after the packet has been proven to be valid and correctly processed by the IBC\nkeepers.\nThus, the ",(0,a.jsx)(n.code,{children:"OnRecvPacket"})," callback only needs to worry about making the appropriate state\nchanges given the packet data without worrying about whether the packet is valid or not."]}),"\n",(0,a.jsxs)(n.p,{children:["Modules may return to the IBC handler an acknowledgement which implements the ",(0,a.jsx)(n.code,{children:"Acknowledgement"})," interface.\nThe IBC handler will then commit this acknowledgement of the packet so that a relayer may relay the\nacknowledgement back to the sender module."]}),"\n",(0,a.jsx)(n.p,{children:"The state changes that occurr during this callback could be:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["the packet processing was successful as indicated by the ",(0,a.jsx)(n.code,{children:"PacketStatus_Success"})," and an ",(0,a.jsx)(n.code,{children:"Acknowledgement()"})," will be written"]}),"\n",(0,a.jsxs)(n.li,{children:["if the packet processing was unsuccessful as indicated by the ",(0,a.jsx)(n.code,{children:"PacketStatus_Failure"})," and an ",(0,a.jsx)(n.code,{children:"ackErr"})," will be written"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Note that with IBC v2 the error acknowledgements are standardised and cannot be customised."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"func (im IBCModule) OnRecvPacket(\n  ctx sdk.Context, sourceChannel string, destinationChannel string, sequence uint64, payload channeltypesv2.Payload, relayer sdk.AccAddress) channeltypesv2.RecvPacketResult {\n\n  // do application state changes based on payload and return the result\n  // state changes should be written via the `RecvPacketResult`\n\n  return recvResult\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"acknowledging-packets",children:"Acknowledging packets"}),"\n",(0,a.jsxs)(n.p,{children:["After a module writes an acknowledgement, a relayer can relay back the acknowledgement to the sender module. The sender module can\nthen process the acknowledgement using the ",(0,a.jsx)(n.code,{children:"OnAcknowledgementPacket"})," callback. The contents of the\nacknowledgement is entirely up to the application developer."]}),"\n",(0,a.jsxs)(n.p,{children:["IBC will pass in the acknowledgements as ",(0,a.jsx)(n.code,{children:"[]byte"})," to this callback. The callback\nis responsible for decoding the acknowledgement and processing it. The acknowledgement is serialised and deserialised using JSON."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"func (im IBCModule) OnAcknowledgementPacket(\n  ctx sdk.Context, sourceChannel string, destinationChannel string, sequence uint64, acknowledgement []byte, payload channeltypesv2.Payload, relayer sdk.AccAddress) error {\n\t\n  // check the type of the acknowledgement\n\n  // if not ackErr, unmarshal the JSON acknowledgement and unmarshal packet payload\n\n  // perform any application specific logic for processing acknowledgement\n\n  // emit events\n  \n  return nil\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"timeout-packets",children:"Timeout packets"}),"\n",(0,a.jsxs)(n.p,{children:["If the timeout for a packet is reached before the packet is successfully received or the receiving\nchain can no longer process the packet the sending chain must process the timeout using\n",(0,a.jsx)(n.code,{children:"OnTimeoutPacket"}),". Again the IBC module will verify that the timeout is\nvalid, so our module only needs to implement the state machine logic for what to do once a\ntimeout is reached and the packet can no longer be received."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"func (im IBCModule) OnTimeoutPacket(\n  ctx sdk.Context, sourceChannel string, destinationChannel string, sequence uint64, payload channeltypesv2.Payload, relayer sdk.AccAddress) error {\n    \n    // unmarshal packet data\n\n    // do custom timeout logic, e.g. refund tokens for transfer\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"packetdataunmarshaler",children:"PacketDataUnmarshaler"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"PacketDataUnmarshaler"})," interface is required for IBC v2 applications to implement because the encoding type is specified by the ",(0,a.jsx)(n.code,{children:"Payload"})," and multiple encoding types are supported."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"type PacketDataUnmarshaler interface {\n\t// UnmarshalPacketData unmarshals the packet data into a concrete type\n\t// the payload is provided and the packet data interface is returned\n\tUnmarshalPacketData(payload channeltypesv2.Payload) (interface{}, error)\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"bind-ports",children:"Bind Ports"}),"\n",(0,a.jsx)(n.p,{children:"Currently, ports must be bound on app initialization. In order to bind modules to their respective ports on initialization, the following needs to be implemented:"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["Note that ",(0,a.jsx)(n.code,{children:"portID"})," does not refer to a certain numerical ID, like ",(0,a.jsx)(n.code,{children:"localhost:8080"})," with a ",(0,a.jsx)(n.code,{children:"portID"})," 8080. Rather it refers to the application module the port binds. For IBC Modules built with the Cosmos SDK, it defaults to the module's name and for Cosmwasm contracts it defaults to the contract address."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Add port ID to the ",(0,a.jsx)(n.code,{children:"GenesisState"})," proto definition:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-protobuf",children:"message GenesisState {\n  string port_id = 1;\n  // other fields\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can see an example for transfer ",(0,a.jsx)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/main/proto/ibc/applications/transfer/v1/genesis.proto",children:"here"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Add port ID as a key to the module store:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'// x/<moduleName>/types/keys.go\nconst (\n  // ModuleName defines the IBC Module name\n  ModuleName = "moduleName"\n\n  // PortID is the default port id that module binds to\n  PortID = "portID"\n\n  // ...\n)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Note that with IBC v2, the version does not need to be added as a key (as required with IBC classic) because versioning of applications is now contained within the ",(0,a.jsx)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel/v2/types/packet.go#L23-L32",children:"packet Payload"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Add port ID to ",(0,a.jsx)(n.code,{children:"x/<moduleName>/types/genesis.go"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"// in x/<moduleName>/types/genesis.go\n\n// DefaultGenesisState returns a GenesisState \n// with the portID defined in keys.go\nfunc DefaultGenesisState() *GenesisState {\n  return &GenesisState{\n    PortId:      PortID,\n    // additional k-v fields\n  }\n}\n\n// Validate performs basic genesis state validation\n//  returning an error upon any failure.\nfunc (gs GenesisState) Validate() error {\n  if err := host.PortIdentifierValidator(gs.PortId); err != nil {\n    return err\n  }\n  //additional validations\n\n  return gs.Params.Validate()\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Set the port in the module keeper's for ",(0,a.jsx)(n.code,{children:"InitGenesis"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"// SetPort sets the portID for the transfer module. Used in InitGenesis\nfunc (k Keeper) SetPort(ctx sdk.Context, portID string) {\n\tstore := k.storeService.OpenKVStore(ctx)\n\tif err := store.Set(types.PortKey, []byte(portID)); err != nil {\n\t\tpanic(err)\n\t}\n}\n\n  // Initialize any other module state, like params with SetParams.\nfunc (k Keeper) SetParams(ctx sdk.Context, params types.Params) {\n\tstore := k.storeService.OpenKVStore(ctx)\n\tbz := k.cdc.MustMarshal(&params)\n\tif err := store.Set([]byte(types.ParamsKey), bz); err != nil {\n\t\tpanic(err)\n\t}\n}\n  // ...\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"The module is set to the desired port. The setting and sealing happens during creation of the IBC router."}),"\n",(0,a.jsx)(n.h2,{id:"implement-the-ibcmodule-keeper",children:"Implement the IBCModule Keeper"}),"\n",(0,a.jsxs)(n.p,{children:["More information on implementing the IBCModule Keepers can be found in the ",(0,a.jsx)(n.a,{href:"/main/ibc/apps/keeper",children:"keepers section"})]}),"\n",(0,a.jsx)(n.h2,{id:"packets-and-payloads",children:"Packets and Payloads"}),"\n",(0,a.jsxs)(n.p,{children:["Applications developers need to define the ",(0,a.jsx)(n.code,{children:"Payload"})," contained within an ",(0,a.jsx)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/fe25b216359fab71b3228461b05dbcdb1a554158/proto/ibc/core/channel/v2/packet.proto#L11-L24",children:"IBC packet"}),". Note that in IBC v2 the ",(0,a.jsx)(n.code,{children:"timeoutHeight"})," has been removed and only ",(0,a.jsx)(n.code,{children:"timeoutTimestamp"})," is used. A packet can contain multiple payloads in a list. Each Payload includes:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"// Payload contains the source and destination ports and payload for the application (version, encoding, raw bytes)\nmessage Payload {\n  // specifies the source port of the packet.\n  string source_port = 1;\n  // specifies the destination port of the packet.\n  string destination_port = 2;\n  // version of the specified application.\n  string version = 3;\n  // the encoding used for the provided value.\n  string encoding = 4;\n  // the raw bytes for the payload.\n  bytes value = 5;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Note that compared to IBC classic, where the applications version and encoding is negotiated during the channel handshake, IBC v2 provides enhanced flexibility. The application version and encoding used by the Payload is defined in the Payload. An example Payload is illustrated below:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'type MyAppPayloadData struct {\n    Field1 string\n    Field2 uint64\n}\n\n// Marshal your payload to bytes using your encoding\nbz, err := json.Marshal(MyAppPayloadData{Field1: "example", Field2: 7})\n\n// Wrap it in a channel v2 Payload\npayload := channeltypesv2.NewPayload(\n    sourcePort,\n    destPort,\n    "my-app-v1",                   // App version\n    channeltypesv2.EncodingJSON,   // Encoding type, e.g. JSON, protobuf or ABI\n    bz,                            // Encoded data\n)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["It is also possible to define your own custom success acknowledgement which will be returned to the sender if the packet is successfully recieved and is returned in the ",(0,a.jsx)(n.code,{children:"RecvPacketResult"}),". Note that if the packet processing fails, it is not possible to define a custom error acknowledgment, a constant ackErr is returned."]}),"\n",(0,a.jsx)(n.h2,{id:"routing",children:"Routing"}),"\n",(0,a.jsxs)(n.p,{children:["More information on implementing the IBC Router can be found in the ",(0,a.jsx)(n.a,{href:"/main/ibc/apps/routing",children:"routing section"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var a=t(96540);const i={},s=a.createContext(i);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:n},e.children)}},50527:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/packet_flow_v2-2c4f0232bf70213ee919fdd1e93670e7.png"}}]);