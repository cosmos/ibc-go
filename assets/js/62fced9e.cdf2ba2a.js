"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[86611],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(96540);const o={},i=s.createContext(o);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},69681:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var s=t(74848),o=t(28453);const i={title:"IBC v2 Transfer",sidebar_label:"IBC v2 Transfer",sidebar_position:10,slug:"/apps/transfer/ics20-v1/ibcv2transfer"},a="IBC v2 Transfer",r={id:"apps/transfer/IBCv2-transfer",title:"IBC v2 Transfer",description:"Much of the core business logic of sending and receiving tokens between chains is unchanged between IBC Classic and IBC v2. Some of the key differences to pay attention to are detailed below.",source:"@site/docs/02-apps/01-transfer/10-IBCv2-transfer.md",sourceDirName:"02-apps/01-transfer",slug:"/apps/transfer/ics20-v1/ibcv2transfer",permalink:"/main/apps/transfer/ics20-v1/ibcv2transfer",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{title:"IBC v2 Transfer",sidebar_label:"IBC v2 Transfer",sidebar_position:10,slug:"/apps/transfer/ics20-v1/ibcv2transfer"},sidebar:"defaultSidebar",previous:{title:"Client",permalink:"/main/apps/transfer/ics20-v1/client"},next:{title:"Overview",permalink:"/main/apps/interchain-accounts/overview"}},c={},d=[{value:"No Channel Handshakes, New Packet Format and Encoding Support",id:"no-channel-handshakes-new-packet-format-and-encoding-support",level:2},{value:"Base Denoms cannot contain slashes",id:"base-denoms-cannot-contain-slashes",level:2},{value:"Changes to the application module interface",id:"changes-to-the-application-module-interface",level:2},{value:"MsgTransfer Entrypoint",id:"msgtransfer-entrypoint",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"ibc-v2-transfer",children:"IBC v2 Transfer"}),"\n",(0,s.jsx)(n.p,{children:"Much of the core business logic of sending and receiving tokens between chains is unchanged between IBC Classic and IBC v2. Some of the key differences to pay attention to are detailed below."}),"\n",(0,s.jsx)(n.h2,{id:"no-channel-handshakes-new-packet-format-and-encoding-support",children:"No Channel Handshakes, New Packet Format and Encoding Support"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["IBC v2 does not establish connection between applications with a channel handshake. Channel identifiers represent Client IDs and are included in the ",(0,s.jsx)(n.code,{children:"Payload"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The source and destination port must be ",(0,s.jsx)(n.code,{children:'"transfer"'})]}),"\n",(0,s.jsxs)(n.li,{children:["The channel IDs ",(0,s.jsx)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/main/modules/apps/transfer/v2/ibc_module.go#L46-L47",children:"must be valid client IDs"})," of the format ",(0,s.jsx)(n.code,{children:"{clientID}-{sequence}"}),", e.g. 08-wasm-007"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel/v2/types/packet.pb.go#L146-L158",children:(0,s.jsx)(n.code,{children:"Payload"})})," contains the ",(0,s.jsx)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/main/modules/apps/transfer/types/packet.pb.go#L28-L39",children:(0,s.jsx)(n.code,{children:"FungibleTokenPacketData"})})," for a token transfer."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The code snippet shows the ",(0,s.jsx)(n.code,{children:"Payload"})," struct."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// Payload contains the source and destination ports and payload for the application (version, encoding, raw bytes)\ntype Payload struct {\n\t// specifies the source port of the packet, e.g. transfer\n\tSourcePort string `protobuf:"bytes,1,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`\n\t// specifies the destination port of the packet, e.g. transfer\n\tDestinationPort string `protobuf:"bytes,2,opt,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`\n\t// version of the specified application\n\tVersion string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`\n\t// the encoding used for the provided value, for transfer this could be JSON, protobuf or ABI\n\tEncoding string `protobuf:"bytes,4,opt,name=encoding,proto3" json:"encoding,omitempty"`\n\t// the raw bytes for the payload.\n\tValue []byte `protobuf:"bytes,5,opt,name=value,proto3" json:"value,omitempty"`\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The code snippet shows the structure of the ",(0,s.jsx)(n.code,{children:"Payload"})," bytes for token transfer"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// FungibleTokenPacketData defines a struct for the packet payload\n// See FungibleTokenPacketData spec:\n// https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer#data-structures\ntype FungibleTokenPacketData struct {\n\t// the token denomination to be transferred\n\tDenom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`\n\t// the token amount to be transferred\n\tAmount string `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`\n\t// the sender address\n\tSender string `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`\n\t// the recipient address on the destination chain\n\tReceiver string `protobuf:"bytes,4,opt,name=receiver,proto3" json:"receiver,omitempty"`\n\t// optional memo\n\tMemo string `protobuf:"bytes,5,opt,name=memo,proto3" json:"memo,omitempty"`\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"base-denoms-cannot-contain-slashes",children:"Base Denoms cannot contain slashes"}),"\n",(0,s.jsxs)(n.p,{children:["With the new ",(0,s.jsx)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/main/modules/apps/transfer/types/token.pb.go#L81-L87",children:(0,s.jsx)(n.code,{children:"Denom"})})," struct, the base denom, i.e. uatom, is separated from the trace - the path the token has travelled. The trace is presented as an array of ",(0,s.jsx)(n.a,{href:"https://github.com/cosmos/ibc-go/blob/main/modules/apps/transfer/types/token.pb.go#L136-L140",children:(0,s.jsx)(n.code,{children:"Hop"})}),"s."]}),"\n",(0,s.jsx)(n.p,{children:'Because IBC v2 no longer uses channels, it is no longer possible to rely on a fixed format for an identifier so using a base denom that contains a "/" is disallowed.'}),"\n",(0,s.jsx)(n.h2,{id:"changes-to-the-application-module-interface",children:"Changes to the application module interface"}),"\n",(0,s.jsxs)(n.p,{children:["Instead of implementing token transfer for ",(0,s.jsx)(n.code,{children:"port.IBCModule"}),", IBC v2 uses the new application interface ",(0,s.jsx)(n.code,{children:"api.IBCModule"}),". More information on the interface differences can be found in the ",(0,s.jsx)(n.a,{href:"/main/ibc/apps/ibcv2apps",children:"application section"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"msgtransfer-entrypoint",children:"MsgTransfer Entrypoint"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"MsgTransfer"})," entrypoint has been retained in order to retain support for the common entrypoint integrated in most existing frontends."]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"MsgTransfer"})," is used with a clientID as the ",(0,s.jsx)(n.code,{children:"msg.SourceChannel"})," then the handler will automatically use the IBC v2 protocol. It will internally call the ",(0,s.jsx)(n.code,{children:"MsgSendPacket"})," endpoint so that the execution flow is the same in the state machine for all IBC v2 packets while still presenting the same endpoint for users."]}),"\n",(0,s.jsx)(n.p,{children:"Of course, we want to still retain support for sending v2 packets on existing channels. The denominations of tokens once they leave the origin chain are prefixed by the port and channel ID in IBC v1. Moreover, the transfer escrow accounts holding the original tokens are generated from the channel IDs. Thus, if we wish to interact these remote tokens using IBC v2, we must still use the v1 channel identifiers that they were originally sent with."}),"\n",(0,s.jsxs)(n.p,{children:["Thus, ",(0,s.jsx)(n.code,{children:"MsgTransfer"})," has an additional ",(0,s.jsx)(n.code,{children:"UseAliasing"})," boolean field to indicate that we wish to use IBC v2 protocol while still using the old v1 channel identifiers. This enables users to interact with the same tokens, DEX pools, and cross-chain DEFI protocols using the same denominations that they had previously with the IBC v2 protocol. To use the ",(0,s.jsx)(n.code,{children:"MsgTransfer"})," with aliasing we can submit the message like so:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'MsgTransfer{\n\tSourcePort:       "transfer",\n\tSourceChannel:    "channel-4", //note: we are using an existing v1 channel identiifer\n\tToken:            "uatom",\n\tSender:           {senderAddr},\n\tReceiver:         {receiverAddr},\n\tTimeoutHeight:    ZeroHeight, // note: IBC v2 does not use timeout height\n\tTimeoutTimestamp: 100_000_000,\n\tMemo:             "",\n\tUseAliasing:      true, // set aliasing to true so the handler uses IBC v2 instead of IBC v1\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);